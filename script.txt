// ==UserScript==
// @name         å·¥ä½œå°æ–‡æœ¬ç¿»è¯‘|å¤åˆ¶æŒ‰é’®|è‡ªåŠ¨ç¼©æ”¾|æŒ‰é’®é«˜åº¦
// @namespace    http://tampermonkey.net/
// @version      8.0.6
// @description  åˆ—å¤åˆ¶æŒ‰é’®ï½œä¿®å¤ç›¸åŒå†…å®¹å¤„ç†ï½œå¿«æ·é”®ï¼š+ è‡ªåŠ¨é«˜åº¦ï½œAlt+Z åˆ‡æ¢ç¿»è¯‘ï½œè°·æ­Œç¿»è¯‘ï½œæ€§èƒ½ä¼˜åŒ–
// @author       You
// @match        https://breeze.opd.easebar.com/*
// @grant        GM_xmlhttpRequest
// @grant        GM_notification
// @grant        GM_getValue
// @grant        GM_setValue
// @connect      translate.googleapis.com
// @run-at       document-idle
// ==/UserScript==

(function () {
    'use strict';

    // ====== é…ç½® ======
    const COLUMN_INDEX = 8; // åªå¤„ç†ç¬¬8åˆ—
    let MIN_FONT_SIZE = 16;
    let MAX_FONT_SIZE = 32;
    const MAX_CELL_HEIGHT = 165;
    const SINGLE_LINE_HEIGHT = 50;
    const BATCH_SIZE = 25;
    let SINGLE_LINE_CHAR_LIMIT = 60;
    const COPY_BTN_CLASS = 'copy-original-btn';
    const ROLE_COPY_BTN_CLASS = 'copy-role-combined-btn';
    const ROLE_ID_ONLY_COPY_BTN_CLASS = 'copy-role-id-only-btn'; // role_idåˆ—ä»…å¤åˆ¶æŒ‰é’®
    const EXPANDED_CLASS = 'expanded-full';

    // ====== æ€§èƒ½ä¼˜åŒ–é…ç½® ======
    const PERFORMANCE_CONFIG = {
        logLevel: 'info',
        batchProcessing: true,
        debounceDelay: 300,
        maxProcessingTime: 1000,
        enablePerformanceMonitor: false,
        scrollThrottle: 100,
        maxCellsPerBatch: 50,
        smartScrollEnabled: true
    };

    // ====== æ™ºèƒ½æŒ‰é’®é«˜åº¦é€‚é…é…ç½® ======
    const BUTTON_ADAPTER_CONFIG = {
        targetButtons: 'button.ant-btn',
        targetButtonTexts: ['Forbid', 'Rename', 'Punish'],
        containerSelector: '.ant-space-item, .ant-space',
        rowSelector: 'td.ant-table-cell, tr',
        transitionDuration: '1ms',
        checkInterval: 300,
        minHeightThreshold: 1,
        maxButtonHeight: 140,
        minButtonHeight: 20,
        buttonHeightOffset: -18,
        singleColumnThreshold: 1,
        isEnabled: false,
        waitForTranslation: true,
        translationWaitTime: 800,
        maxRetryCount: 3
    };

    let isTranslationEnabled = true;
    const translationCache = new Map();
    let processing = false;
    let processDebounceTimer = null;
    let roleIdColumnIndexes = [];
    let observer = null;
    let tableMutationObserver = null;

    // ====== æŒ‰é’®é«˜åº¦é€‚é…ç›¸å…³å˜é‡ ======
    const processedButtons = new Set();
    let buttonAdapterObserver = null;
    const processedCopyButtons = new Set();
    const processedCells = new Set();
    const pendingButtonAdaptations = new Map();

    // ====== æ§åˆ¶é¢æ¿çŠ¶æ€å˜é‡ ======
    let controlPanelMinimized = true;
    let controlPanel = null;
    let minimizeBtn = null;
    let contentContainer = null;
    let panelHeader = null;

    // ====== æ™ºèƒ½æ»šåŠ¨ç›¸å…³å˜é‡ ======
    let scrollHandlersAttached = false;

    // ====== æ€§èƒ½ç›‘æ§ ======
    let performanceStats = {
        cellsProcessed: 0,
        translationsCompleted: 0,
        buttonsAdapted: 0,
        startTime: 0
    };

    // ====== æ—¥å¿—å‡½æ•° ======
    function log(level, message, data) {
        const levels = { debug: 0, info: 1, warn: 2, error: 3 };
        const currentLevel = levels[PERFORMANCE_CONFIG.logLevel] || 1;
        const messageLevel = levels[level] || 1;

        if (messageLevel >= currentLevel) {
            if (data) {
                console[level](`ğŸ”§ ${message}`, data);
            } else {
                console[level](`ğŸ”§ ${message}`);
            }
        }
    }

    function init() {
        log('info', `å·¥ä½œå°ç¿»è¯‘ä¸å¤åˆ¶åŠ©æ‰‹ v8.0.6 å·²åŠ è½½ - ä¿®å¤role_idåˆ—å¤åˆ¶æŒ‰é’®å’Œç›¸åŒå†…å®¹å¤„ç†`);
        performanceStats.startTime = Date.now();
        loadSettings();
        addGlobalStyle();
        bindShortcut();
        startStableMonitoring();
        setupTableSortDetection();
        initButtonHeightAdapter();
        createControlPanel();

        setTimeout(() => {
            initSmartScrollHandling();
        }, 2000);
    }

    // ====== ä¿®å¤çš„æ™ºèƒ½æ»šåŠ¨å¤„ç† ======
    function initSmartScrollHandling() {
        if (!PERFORMANCE_CONFIG.smartScrollEnabled || scrollHandlersAttached) {
            return;
        }

        log('info', 'åˆå§‹åŒ–ä¼˜åŒ–çš„æ™ºèƒ½æ»šåŠ¨å¤„ç†...');

        const handleWheelEvent = (e) => {
            let target = e.target;
            let isFixedHeightCell = false;

            for (let i = 0; i < 3 && target && target !== document.body; i++) {
                if (target.classList && target.classList.contains('fixed-height-cell')) {
                    isFixedHeightCell = true;
                    break;
                }
                target = target.parentElement;
            }

            if (isFixedHeightCell) {
                const fixedHeightCell = e.target.closest('.fixed-height-cell');
                if (fixedHeightCell && fixedHeightCell.scrollHeight > fixedHeightCell.clientHeight) {
                    e.preventDefault();
                    e.stopPropagation();

                    const delta = e.deltaY || e.detail || (e.wheelDelta ? -e.wheelDelta / 40 : 0);
                    fixedHeightCell.scrollTop += delta * 0.8;
                }
            }
        };

        const passiveOptions = { passive: false, capture: true };
        document.addEventListener('wheel', handleWheelEvent, passiveOptions);
        document.addEventListener('mousewheel', handleWheelEvent, passiveOptions);

        scrollHandlersAttached = true;
        log('info', 'æ™ºèƒ½æ»šåŠ¨å¤„ç†å·²å¯ç”¨ï¼ˆä¼˜åŒ–ç‰ˆï¼‰');
    }

    function disableSmartScrollHandling() {
        if (!scrollHandlersAttached) return;

        const events = ['wheel', 'mousewheel', 'DOMMouseScroll'];
        events.forEach(event => {
            document.removeEventListener(event, handleWheelEvent, { capture: true });
        });

        scrollHandlersAttached = false;
        log('info', 'æ™ºèƒ½æ»šåŠ¨å¤„ç†å·²ç¦ç”¨');
    }

    // ====== åŠ è½½è®¾ç½® ======
    function loadSettings() {
        try {
            const savedMinFontSize = GM_getValue('minFontSize');
            const savedMaxFontSize = GM_getValue('maxFontSize');
            const savedCharLimit = GM_getValue('charLimit');
            const savedTranslationEnabled = GM_getValue('translationEnabled');
            const savedButtonAdapterEnabled = GM_getValue('buttonAdapterEnabled');
            const savedPanelMinimized = GM_getValue('panelMinimized');
            const savedSmartScrollEnabled = GM_getValue('smartScrollEnabled');

            if (savedMinFontSize !== undefined) MIN_FONT_SIZE = savedMinFontSize;
            if (savedMaxFontSize !== undefined) MAX_FONT_SIZE = savedMaxFontSize;
            if (savedCharLimit !== undefined) SINGLE_LINE_CHAR_LIMIT = savedCharLimit;
            if (savedTranslationEnabled !== undefined) isTranslationEnabled = savedTranslationEnabled;
            if (savedButtonAdapterEnabled !== undefined) BUTTON_ADAPTER_CONFIG.isEnabled = savedButtonAdapterEnabled;
            if (savedPanelMinimized !== undefined) controlPanelMinimized = savedPanelMinimized;
            if (savedSmartScrollEnabled !== undefined) PERFORMANCE_CONFIG.smartScrollEnabled = savedSmartScrollEnabled;
        } catch (error) {
            log('warn', 'åŠ è½½è®¾ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼:', error);
        }
    }

    // ====== ä¿å­˜è®¾ç½® ======
    function saveSettings() {
        try {
            GM_setValue('minFontSize', MIN_FONT_SIZE);
            GM_setValue('maxFontSize', MAX_FONT_SIZE);
            GM_setValue('charLimit', SINGLE_LINE_CHAR_LIMIT);
            GM_setValue('translationEnabled', isTranslationEnabled);
            GM_setValue('buttonAdapterEnabled', BUTTON_ADAPTER_CONFIG.isEnabled);
            GM_setValue('panelMinimized', controlPanelMinimized);
            GM_setValue('smartScrollEnabled', PERFORMANCE_CONFIG.smartScrollEnabled);
        } catch (error) {
            log('warn', 'ä¿å­˜è®¾ç½®å¤±è´¥:', error);
        }
    }

    // ====== åˆ›å»ºæ§åˆ¶é¢æ¿ ======
    function createControlPanel() {
        controlPanel = document.createElement('div');
        controlPanel.id = 'translation-assistant-control-panel';
        controlPanel.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            padding: 0;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
            font-size: 12px;
            color: #333;
            min-width: 30px;
            width: 30px;
            height: 30px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            overflow: hidden;
        `;

        const miniButton = document.createElement('div');
        miniButton.id = 'control-panel-mini-button';
        miniButton.style.cssText = `
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            color: #1890ff;
            background: rgba(24, 144, 255, 0.1);
            border-radius: 6px;
            transition: all 0.2s ease;
        `;
        miniButton.textContent = '+';
        miniButton.title = 'å±•å¼€æ§åˆ¶é¢æ¿ (å¿«æ·é”®: -)';

        miniButton.addEventListener('mouseover', () => {
            miniButton.style.background = 'rgba(24, 144, 255, 0.2)';
        });

        miniButton.addEventListener('mouseout', () => {
            miniButton.style.background = 'rgba(24, 144, 255, 0.1)';
        });

        miniButton.addEventListener('click', toggleControlPanel);

        panelHeader = document.createElement('div');
        panelHeader.style.cssText = `
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(24, 144, 255, 0.15) 0%, rgba(24, 144, 255, 0.1) 100%);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px 8px 0 0;
            cursor: move;
        `;

        const title = document.createElement('div');
        title.style.cssText = `
            font-weight: bold;
            color: #1890ff;
            font-size: 13px;
        `;
        title.textContent = 'ğŸ”§ ç¿»è¯‘åŠ©æ‰‹';

        minimizeBtn = document.createElement('button');
        minimizeBtn.style.cssText = `
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
            color: #666;
            transition: all 0.2s ease;
            font-weight: bold;
        `;
        minimizeBtn.textContent = 'âˆ’';
        minimizeBtn.title = 'æœ€å°åŒ–é¢æ¿';
        minimizeBtn.onmouseover = () => {
            minimizeBtn.style.background = 'rgba(24, 144, 255, 0.1)';
        };
        minimizeBtn.onmouseout = () => {
            minimizeBtn.style.background = 'none';
        };
        minimizeBtn.onclick = toggleControlPanel;

        panelHeader.appendChild(title);
        panelHeader.appendChild(minimizeBtn);

        contentContainer = document.createElement('div');
        contentContainer.style.cssText = `
            display: none;
            padding: 16px;
            max-height: 400px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.95);
        `;

        contentContainer.innerHTML = `
            <div style="margin-bottom: 16px;">
                <div style="font-weight: bold; margin-bottom: 8px; color: #333;">åŸºç¡€åŠŸèƒ½</div>

                <div style="margin-bottom: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 4px;">
                        <input type="checkbox" id="translation-toggle" ${isTranslationEnabled ? 'checked' : ''}
                               style="margin-right: 8px; transform: scale(1.1);">
                        <span>å¯ç”¨ç¿»è¯‘åŠŸèƒ½</span>
                    </label>
                </div>

                <div style="margin-bottom: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="button-height-adapter-toggle"
                               ${BUTTON_ADAPTER_CONFIG.isEnabled ? 'checked' : ''}
                               style="margin-right: 8px; transform: scale(1.1);">
                        <span>å¯ç”¨æŒ‰é’®é«˜åº¦é€‚é…</span>
                    </label>
                </div>

                <div style="margin-bottom: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="smart-scroll-toggle" ${PERFORMANCE_CONFIG.smartScrollEnabled ? 'checked' : ''}
                               style="margin-right: 8px; transform: scale(1.1);">
                        <span>å¯ç”¨æ™ºèƒ½æ»šåŠ¨å…¼å®¹</span>
                    </label>
                </div>
            </div>

            <div style="margin-bottom: 16px;">
                <div style="font-weight: bold; margin-bottom: 8px; color: #333;">å­—ä½“è®¾ç½®</div>

                <div style="margin-bottom: 8px;">
                    <label style="display: block; margin-bottom: 4px; font-size: 11px; color: #666;">æœ€å°å­—ä½“å¤§å°</label>
                    <input type="number" id="min-font-size" value="${MIN_FONT_SIZE}" min="10" max="24"
                           style="width: 100%; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                </div>

                <div style="margin-bottom: 8px;">
                    <label style="display: block; margin-bottom: 4px; font-size: 11px; color: #666;">æœ€å¤§å­—ä½“å¤§å°</label>
                    <input type="number" id="max-font-size" value="${MAX_FONT_SIZE}" min="20" max="48"
                           style="width: 100%; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                </div>

                <div>
                    <label style="display: block; margin-bottom: 4px; font-size: 11px; color: #666;">å•è¡Œå­—ç¬¦æ•°é™åˆ¶</label>
                    <input type="number" id="single-line-char-limit" value="${SINGLE_LINE_CHAR_LIMIT}" min="20" max="120"
                           style="width: 100%; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                </div>
            </div>

            <div style="margin-bottom: 16px;">
                <div style="font-weight: bold; margin-bottom: 8px; color: #333;">æ€§èƒ½è®¾ç½®</div>

                <div style="margin-bottom: 8px;">
                    <label style="display: block; margin-bottom: 4px; font-size: 11px; color: #666;">æ—¥å¿—çº§åˆ«</label>
                    <select id="log-level" style="width: 100%; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                        <option value="error">ä»…é”™è¯¯</option>
                        <option value="warn">è­¦å‘Šå’Œé”™è¯¯</option>
                        <option value="info" selected>ä¿¡æ¯</option>
                        <option value="debug">è°ƒè¯•</option>
                    </select>
                </div>

                <div style="margin-bottom: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="performance-monitor-toggle"
                               ${PERFORMANCE_CONFIG.enablePerformanceMonitor ? 'checked' : ''}
                               style="margin-right: 8px; transform: scale(1.1);">
                        <span>å¯ç”¨æ€§èƒ½ç›‘æ§</span>
                    </label>
                </div>
            </div>

            <div style="margin-bottom: 12px;">
                <button id="apply-settings-btn"
                        style="width: 100%; padding: 8px; background: #1890ff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; margin-bottom: 8px;">
                    åº”ç”¨è®¾ç½®
                </button>
                <button id="reset-settings-btn"
                        style="width: 100%; padding: 6px; background: #f5f5f5; color: #666; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 11px;">
                    é‡ç½®ä¸ºé»˜è®¤
                </button>
            </div>

            <div style="margin-bottom: 12px; padding: 8px; background: rgba(24, 144, 255, 0.05); border-radius: 4px; font-size: 11px;">
                <div style="font-weight: bold; margin-bottom: 4px; color: #666;">å¿«æ·é”®</div>
                <div>Alt+Z: å¼€å…³ç¿»è¯‘</div>
                <div>=: å¼€å…³æŒ‰é’®é«˜åº¦é€‚é…</div>
                <div>-: å¼€å…³æ§åˆ¶é¢æ¿</div>
            </div>

            <div style="font-size: 10px; color: #666; text-align: center; border-top: 1px solid #eee; padding-top: 8px;">
                v8.0.6 | ä¿®å¤role_idåˆ—å¤åˆ¶æŒ‰é’®å’Œç›¸åŒå†…å®¹å¤„ç†
            </div>
        `;

        controlPanel.appendChild(miniButton);
        controlPanel.appendChild(panelHeader);
        controlPanel.appendChild(contentContainer);
        document.body.appendChild(controlPanel);

        addDragFunctionality(controlPanel, panelHeader);
        bindControlPanelEvents();

        if (controlPanelMinimized) {
            minimizeControlPanel();
        } else {
            expandControlPanel();
        }
    }

    function minimizeControlPanel() {
        const miniButton = controlPanel.querySelector('#control-panel-mini-button');
        if (miniButton) miniButton.style.display = 'flex';
        contentContainer.style.display = 'none';
        panelHeader.style.display = 'none';
        controlPanel.style.minWidth = '30px';
        controlPanel.style.width = '30px';
        controlPanel.style.height = '30px';
        controlPanelMinimized = true;
        saveSettings();
    }

    function expandControlPanel() {
        const miniButton = controlPanel.querySelector('#control-panel-mini-button');
        if (miniButton) miniButton.style.display = 'none';
        contentContainer.style.display = 'block';
        panelHeader.style.display = 'flex';
        controlPanel.style.minWidth = '240px';
        controlPanel.style.width = '280px';
        controlPanel.style.height = '';
        controlPanelMinimized = false;
        saveSettings();
    }

    function toggleControlPanel() {
        if (controlPanelMinimized) {
            expandControlPanel();
        } else {
            minimizeControlPanel();
        }
    }

    function addDragFunctionality(panel, handle) {
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        handle.onmousedown = (e) => {
            isDragging = true;
            dragOffsetX = e.clientX - panel.offsetLeft;
            dragOffsetY = e.clientY - panel.offsetTop;
            handle.style.cursor = 'grabbing';
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        };

        function handleMouseMove(e) {
            if (isDragging) {
                panel.style.left = (e.clientX - dragOffsetX) + 'px';
                panel.style.top = (e.clientY - dragOffsetY) + 'px';
                panel.style.right = 'auto';
            }
        }

        function handleMouseUp() {
            isDragging = false;
            handle.style.cursor = 'move';
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        }
    }

    function bindControlPanelEvents() {
        const translationToggle = controlPanel.querySelector('#translation-toggle');
        translationToggle.addEventListener('change', (e) => {
            isTranslationEnabled = e.target.checked;
            saveSettings();
            log('info', `ç¿»è¯‘åŠŸèƒ½å·²${isTranslationEnabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`);

            if (isTranslationEnabled) {
                reprocessTranslationsOnly();
            } else {
                removeTranslationsOnly();
            }
        });

        const buttonHeightToggle = controlPanel.querySelector('#button-height-adapter-toggle');
        buttonHeightToggle.addEventListener('change', (e) => {
            BUTTON_ADAPTER_CONFIG.isEnabled = e.target.checked;
            saveSettings();
            log('info', `æŒ‰é’®é«˜åº¦é€‚é…åŠŸèƒ½å·²${BUTTON_ADAPTER_CONFIG.isEnabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`);

            if (BUTTON_ADAPTER_CONFIG.isEnabled) {
                processedButtons.clear();
                pendingButtonAdaptations.clear();
                setTimeout(() => {
                    initialButtonScan();
                }, 100);
            } else {
                processedButtons.clear();
                pendingButtonAdaptations.clear();
                document.querySelectorAll('button[data-height-adapted="true"]').forEach(btn => {
                    btn.removeAttribute('data-height-adapted');
                    btn.style.height = '';
                    btn.style.minHeight = '';
                    btn.style.lineHeight = '';
                    btn.style.maxHeight = '';
                });
            }
        });

        const smartScrollToggle = controlPanel.querySelector('#smart-scroll-toggle');
        smartScrollToggle.addEventListener('change', (e) => {
            PERFORMANCE_CONFIG.smartScrollEnabled = e.target.checked;
            saveSettings();

            if (PERFORMANCE_CONFIG.smartScrollEnabled) {
                initSmartScrollHandling();
            } else {
                disableSmartScrollHandling();
            }

            log('info', `æ™ºèƒ½æ»šåŠ¨å…¼å®¹å·²${PERFORMANCE_CONFIG.smartScrollEnabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
        });

        const logLevelSelect = controlPanel.querySelector('#log-level');
        logLevelSelect.value = PERFORMANCE_CONFIG.logLevel;
        logLevelSelect.addEventListener('change', (e) => {
            PERFORMANCE_CONFIG.logLevel = e.target.value;
            log('info', `æ—¥å¿—çº§åˆ«å·²è®¾ç½®ä¸º: ${PERFORMANCE_CONFIG.logLevel}`);
        });

        const performanceMonitorToggle = controlPanel.querySelector('#performance-monitor-toggle');
        performanceMonitorToggle.addEventListener('change', (e) => {
            PERFORMANCE_CONFIG.enablePerformanceMonitor = e.target.checked;
            log('info', `æ€§èƒ½ç›‘æ§å·²${PERFORMANCE_CONFIG.enablePerformanceMonitor ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
        });

        const applyBtn = controlPanel.querySelector('#apply-settings-btn');
        applyBtn.addEventListener('click', () => {
            applySettings();
        });

        const resetBtn = controlPanel.querySelector('#reset-settings-btn');
        resetBtn.addEventListener('click', () => {
            resetSettings();
        });
    }

    function applySettings() {
        const minFontInput = controlPanel.querySelector('#min-font-size');
        const maxFontInput = controlPanel.querySelector('#max-font-size');
        const charLimitInput = controlPanel.querySelector('#single-line-char-limit');

        const newMinFont = parseInt(minFontInput.value);
        const newMaxFont = parseInt(maxFontInput.value);
        const newCharLimit = parseInt(charLimitInput.value);

        if (newMinFont >= 10 && newMinFont <= 24 &&
            newMaxFont >= 20 && newMaxFont <= 48 &&
            newMinFont < newMaxFont &&
            newCharLimit >= 20 && newCharLimit <= 120) {

            MIN_FONT_SIZE = newMinFont;
            MAX_FONT_SIZE = newMaxFont;
            SINGLE_LINE_CHAR_LIMIT = newCharLimit;
            saveSettings();

            log('info', `è®¾ç½®å·²åº”ç”¨: å­—ä½“${MIN_FONT_SIZE}-${MAX_FONT_SIZE}px, å•è¡Œå­—ç¬¦æ•°${SINGLE_LINE_CHAR_LIMIT}`);
            adjustFontSizesOnly();
            showNotification('è®¾ç½®å·²åº”ç”¨', 'success');
        } else {
            showNotification('è®¾ç½®æ— æ•ˆï¼Œè¯·æ£€æŸ¥è¾“å…¥å€¼', 'error');
        }
    }

    function resetSettings() {
        MIN_FONT_SIZE = 16;
        MAX_FONT_SIZE = 32;
        SINGLE_LINE_CHAR_LIMIT = 60;
        isTranslationEnabled = true;
        BUTTON_ADAPTER_CONFIG.isEnabled = false;
        PERFORMANCE_CONFIG.logLevel = 'info';
        PERFORMANCE_CONFIG.enablePerformanceMonitor = false;
        PERFORMANCE_CONFIG.smartScrollEnabled = true;

        controlPanel.querySelector('#min-font-size').value = MIN_FONT_SIZE;
        controlPanel.querySelector('#max-font-size').value = MAX_FONT_SIZE;
        controlPanel.querySelector('#single-line-char-limit').value = SINGLE_LINE_CHAR_LIMIT;
        controlPanel.querySelector('#translation-toggle').checked = isTranslationEnabled;
        controlPanel.querySelector('#button-height-adapter-toggle').checked = BUTTON_ADAPTER_CONFIG.isEnabled;
        controlPanel.querySelector('#smart-scroll-toggle').checked = PERFORMANCE_CONFIG.smartScrollEnabled;
        controlPanel.querySelector('#log-level').value = PERFORMANCE_CONFIG.logLevel;
        controlPanel.querySelector('#performance-monitor-toggle').checked = PERFORMANCE_CONFIG.enablePerformanceMonitor;

        saveSettings();
        adjustFontSizesOnly();

        if (BUTTON_ADAPTER_CONFIG.isEnabled) {
            initialButtonScan();
        } else {
            const adaptedButtons = document.querySelectorAll('button[data-height-adapted="true"]');
            adaptedButtons.forEach(btn => {
                btn.removeAttribute('data-height-adapted');
                btn.style.height = '';
                btn.style.minHeight = '';
                btn.style.lineHeight = '';
                btn.style.maxHeight = '';
            });
            processedButtons.clear();
            pendingButtonAdaptations.clear();
        }

        if (PERFORMANCE_CONFIG.smartScrollEnabled) {
            initSmartScrollHandling();
        }

        log('info', 'è®¾ç½®å·²é‡ç½®ä¸ºé»˜è®¤å€¼');
        showNotification('è®¾ç½®å·²é‡ç½®', 'success');
    }

    function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 10001;
            padding: 8px 16px;
            background: ${type === 'success' ? '#52c41a' : type === 'error' ? '#ff4d4f' : '#1890ff'};
            color: white;
            border-radius: 4px;
            font-size: 12px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
            animation: slideInRight 0.3s ease-out;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        `;
        notification.textContent = message;

        document.body.appendChild(notification);

        setTimeout(() => {
            notification.style.animation = 'slideOutRight 0.3s ease-in';
            setTimeout(() => {
                if (notification.parentNode) {
                    document.body.removeChild(notification);
                }
            }, 300);
        }, 2000);
    }

    // ====== ä¿®å¤çš„ç¨³å®šç›‘æ§ç³»ç»Ÿ ======
    function startStableMonitoring() {
        log('info', 'å¯åŠ¨ç¨³å®šç›‘æ§ç³»ç»Ÿ...');

        observer = new MutationObserver((mutations) => {
            let shouldProcess = false;

            for (const mutation of mutations) {
                if (mutation.type === 'childList') {
                    for (const node of mutation.addedNodes) {
                        if (node.nodeType === 1) {
                            if (node.matches && (
                                node.matches('.ant-table-tbody') ||
                                node.matches('.ant-table-tbody tr') ||
                                node.matches('.ant-table') ||
                                node.querySelector('.ant-table-tbody')
                            )) {
                                shouldProcess = true;
                                break;
                            }
                        }
                    }
                }
            }

            if (shouldProcess) {
                log('debug', 'æ£€æµ‹åˆ°è¡¨æ ¼æ›´æ–°ï¼Œå¤„ç†æ–°å†…å®¹...');
                scheduleProcessNewCells();
                setTimeout(() => {
                    findRoleIdColumns();
                    addCopyButtonsToRoleIdColumns();
                    addRoleIdOnlyCopyButtons(); // æ·»åŠ role_idåˆ—ä»…å¤åˆ¶æŒ‰é’®
                }, 500);
            }
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        setTimeout(() => {
            processAllCellsInBatches();
            findRoleIdColumns();
            addCopyButtonsToRoleIdColumns();
            addRoleIdOnlyCopyButtons(); // æ·»åŠ role_idåˆ—ä»…å¤åˆ¶æŒ‰é’®
        }, 1500);
    }

    function processAllCellsInBatches() {
        if (processing) return;
        processing = true;

        const startTime = Date.now();
        const allCells = Array.from(document.querySelectorAll(`.ant-table-tbody > tr > td:nth-child(${COLUMN_INDEX})`));
        const unprocessed = allCells.filter(cell => {
            const text = getCleanCellText(cell);
            const cellKey = getCellKey(cell);
            return text && text.length >= 2 && !processedCells.has(cellKey);
        });

        log('info', `å¤„ç† ${Math.min(unprocessed.length, PERFORMANCE_CONFIG.maxCellsPerBatch)} ä¸ªç¬¬8åˆ—å•å…ƒæ ¼`);

        const cellsToProcess = unprocessed.slice(0, PERFORMANCE_CONFIG.maxCellsPerBatch);

        for (const cell of cellsToProcess) {
            wrapCellContent(cell);
            const cellKey = getCellKey(cell);
            processedCells.add(cellKey);
            performanceStats.cellsProcessed++;
        }

        for (let i = 0; i < cellsToProcess.length; i += BATCH_SIZE) {
            const batch = cellsToProcess.slice(i, i + BATCH_SIZE);
            setTimeout(() => {
                for (const cell of batch) {
                    const text = getCleanCellText(cell);
                    if (!text || text.length < 2) continue;

                    adjustFontSizeForCell(cell);

                    if (isTranslationEnabled && cell.dataset.translated !== 'true') {
                        translateIfNeeded(cell);
                    }

                    if (BUTTON_ADAPTER_CONFIG.isEnabled && BUTTON_ADAPTER_CONFIG.waitForTranslation) {
                        scheduleButtonAdaptationForRow(cell.closest('tr'));
                    }
                }
            }, 0);
        }

        processing = false;

        if (PERFORMANCE_CONFIG.enablePerformanceMonitor) {
            const endTime = Date.now();
            log('debug', `å•å…ƒæ ¼å¤„ç†å®Œæˆï¼Œè€—æ—¶: ${endTime - startTime}ms`);
        }
    }

    // ====== ä¿®å¤ï¼šä½¿ç”¨æ›´å”¯ä¸€çš„å•å…ƒæ ¼æ ‡è¯† ======
    function getCellKey(cell) {
        const row = cell.closest('tr');
        const rowIndex = row ? Array.from(row.parentElement.children).indexOf(row) : 'unknown';
        const columnIndex = Array.from(cell.parentElement.children).indexOf(cell) + 1;
        const text = getCleanCellText(cell);
        // ä½¿ç”¨è¡Œç´¢å¼•ã€åˆ—ç´¢å¼•å’Œæ–‡æœ¬å†…å®¹åˆ›å»ºå”¯ä¸€é”®
        return `${rowIndex}-${columnIndex}-${text}`;
    }

    function scheduleProcessNewCells() {
        if (processDebounceTimer) {
            clearTimeout(processDebounceTimer);
        }
        processDebounceTimer = setTimeout(() => {
            processAllCellsInBatches();
        }, PERFORMANCE_CONFIG.debounceDelay);
    }

    // ====== ä¿®å¤çš„ç¿»è¯‘å¤„ç†å‡½æ•° ======
    function reprocessTranslationsOnly() {
        log('info', 'åªé‡æ–°ç¿»è¯‘ç¬¬8åˆ—å†…å®¹...');
        const allCells = Array.from(document.querySelectorAll(`.ant-table-tbody > tr > td:nth-child(${COLUMN_INDEX})`));

        allCells.forEach(cell => {
            const container = cell.querySelector('.fixed-height-cell');
            if (!container) return;

            const translationSpan = container.querySelector('.translation');
            if (translationSpan) {
                translationSpan.remove();
            }

            cell.dataset.translated = '';
            translateIfNeeded(cell);
        });
    }

    function removeTranslationsOnly() {
        log('info', 'åªç§»é™¤ç¬¬8åˆ—ç¿»è¯‘å†…å®¹...');
        const allCells = Array.from(document.querySelectorAll(`.ant-table-tbody > tr > td:nth-child(${COLUMN_INDEX})`));

        allCells.forEach(cell => {
            const container = cell.querySelector('.fixed-height-cell');
            if (!container) return;

            const translationSpan = container.querySelector('.translation');
            if (translationSpan) {
                translationSpan.remove();
            }

            cell.dataset.translated = 'false';
            adjustFontSizeForCell(cell);
        });
    }

    function adjustFontSizesOnly() {
        log('info', 'åªè°ƒæ•´ç¬¬8åˆ—å­—ä½“å¤§å°...');
        const allCells = Array.from(document.querySelectorAll(`.ant-table-tbody > tr > td:nth-child(${COLUMN_INDEX})`));

        allCells.forEach(cell => {
            adjustFontSizeForCell(cell);
        });
    }

    // ====== ä¿®å¤çš„å…¨å±€æ ·å¼ - åªå½±å“ç¬¬8åˆ— ======
    function addGlobalStyle() {
        const style = document.createElement('style');
        style.textContent = `
            /* åªé’ˆå¯¹ç¬¬8åˆ—çš„ç‰¹æ®Šå¤„ç† */
            .ant-table-tbody > tr > td:nth-child(${COLUMN_INDEX}) {
                position: relative !important;
                vertical-align: top !important;
                text-align: left !important;
                padding: 0 !important;
                margin: 0 !important;
                line-height: normal !important;
                white-space: normal !important;
                overflow: visible !important;
                pointer-events: auto !important;
                box-sizing: border-box !important;
                height: auto !important;
                min-height: auto !important;
                max-height: none !important;
            }

            .ant-table-thead > tr > th:nth-child(${COLUMN_INDEX}) {
                vertical-align: middle !important;
                text-align: center !important;
                padding: 8px !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                line-height: normal !important;
                height: auto !important;
                min-height: auto !important;
                max-height: none !important;
            }

            /* role_idåˆ—æ ·å¼ */
            .ant-table-tbody > tr > td[data-is-role-id="true"] {
                position: relative !important;
            }

            /* å…¶ä»–åˆ—ä¿æŒåŸæ ·ï¼Œä¸åº”ç”¨ä»»ä½•ç‰¹æ®Šæ ·å¼ */
            .ant-table-container,
            .ant-table-content,
            .ant-table-body {
                overflow: auto !important;
            }

            .fixed-height-cell {
                position: relative;
                width: 100%;
                max-height: ${MAX_CELL_HEIGHT}px;
                overflow-y: auto;
                overflow-x: hidden;
                padding: 4px 6px;
                box-sizing: border-box;
                line-height: 1.1;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-size: ${MIN_FONT_SIZE}px;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
            }

            .fixed-height-cell.single-line {
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                height: ${SINGLE_LINE_HEIGHT}px;
                line-height: ${SINGLE_LINE_HEIGHT}px;
            }

            .fixed-height-cell.no-scroll {
                overflow: hidden;
            }

            .fixed-height-cell .original {
                display: inline;
                font-weight: normal;
            }

            .fixed-height-cell .translation {
                display: inline;
                font-weight: bold !important;
                margin-left: 8px;
            }

            .fixed-height-cell.long-text {
                cursor: pointer;
                background: linear-gradient(135deg, rgba(24, 144, 255, 0.05) 0%, rgba(24, 144, 255, 0.1) 100%);
                border-radius: 4px;
                border: 1px solid rgba(24, 144, 255, 0.2);
                transition: all 0.2s ease;
            }

            .fixed-height-cell.long-text:hover {
                background: linear-gradient(135deg, rgba(24, 144, 255, 0.1) 0%, rgba(24, 144, 255, 0.2) 100%);
                border-color: rgba(24, 144, 255, 0.4);
            }

            .fixed-height-cell.${EXPANDED_CLASS} {
                max-height: none !important;
                overflow: visible !important;
                background: rgba(24, 144, 255, 0.05);
                border: 1px solid rgba(24, 144, 255, 0.3);
                border-radius: 6px;
                padding: 8px;
            }

            .fixed-height-cell.${EXPANDED_CLASS} .original,
            .fixed-height-cell.${EXPANDED_CLASS} .translation {
                display: block;
                margin: 4px 0;
                word-break: break-word;
            }

            /* ç¬¬8åˆ—å¤åˆ¶æŒ‰é’® */
            .${COPY_BTN_CLASS} {
                position: absolute;
                top: 4px;
                right: 4px;
                width: 32px;
                height: 35px;
                background: rgba(255, 255, 255, 0.2);
                border: 1px solid rgba(0, 0, 0, 0.1);
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.2s ease;
                z-index: 10;
            }

            .${COPY_BTN_CLASS}:hover {
                background: rgba(255, 255, 255, 0.6);
                border-color: rgba(24, 144, 255, 0.3);
                transform: scale(1.1);
            }

            .${COPY_BTN_CLASS}.copied {
                background: rgba(82, 196, 26, 0.9);
                color: white;
                border-color: #52c41a;
            }

            .${COPY_BTN_CLASS}.error {
                background: rgba(255, 77, 79, 0.9);
                color: white;
                border-color: #ff4d4f;
            }

            /* role_idåˆ—ç»„åˆå¤åˆ¶æŒ‰é’® */
            .${ROLE_COPY_BTN_CLASS} {
                position: absolute;
                top: 4px;
                right: 4px;
                width: 28px;
                height: 30px;
                background: rgba(255, 255, 255, 0.2);
                border: 1px solid rgba(0, 0, 0, 0.1);
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                font-size: 12px;
                font-weight: bold;
                transition: all 0.2s ease;
                z-index: 10;
                color: #666;
            }

            .${ROLE_COPY_BTN_CLASS}:hover {
                background: rgba(255, 255, 255, 0.6);
                border-color: rgba(24, 144, 255, 0.3);
                transform: scale(1.1);
                color: #1890ff;
            }

            .${ROLE_COPY_BTN_CLASS}.copied {
                background: rgba(82, 196, 26, 0.9);
                color: white;
                border-color: #52c41a;
            }

            .${ROLE_COPY_BTN_CLASS}.error {
                background: rgba(255, 77, 79, 0.9);
                color: white;
                border-color: #ff4d4f;
            }

            /* role_idåˆ—ä»…å¤åˆ¶æŒ‰é’® */
            .${ROLE_ID_ONLY_COPY_BTN_CLASS} {
                position: absolute;
                top: 4px;
                left: 4px;
                width: 30px;
                height: 30px;
                background: rgba(255, 255, 255, 0.2);
                border: 1px solid rgba(0, 0, 0, 0.1);
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                font-size: 12px;
                font-weight: bold;
                transition: all 0.2s ease;
                z-index: 10;
                color: #666;
            }

            .${ROLE_ID_ONLY_COPY_BTN_CLASS}:hover {
                background: rgba(255, 255, 255, 0.6);
                border-color: rgba(24, 144, 255, 0.3);
                transform: scale(1.1);
                color: #1890ff;
            }

            .${ROLE_ID_ONLY_COPY_BTN_CLASS}.copied {
                background: rgba(82, 196, 26, 0.9);
                color: white;
                border-color: #52c41a;
            }

            .${ROLE_ID_ONLY_COPY_BTN_CLASS}.error {
                background: rgba(255, 77, 79, 0.9);
                color: white;
                border-color: #ff4d4f;
            }

            button.ant-btn[data-height-adapted="true"] {
                transition: height ${BUTTON_ADAPTER_CONFIG.transitionDuration} ease-in-out !important;
                box-sizing: border-box !important;
                overflow: hidden !important;
            }

            #translation-assistant-control-panel {
                animation: slideIn 0.3s ease-out;
            }

            #control-panel-mini-button:hover {
                background: rgba(24, 144, 255, 0.2) !important;
                transform: scale(1.05);
            }

            @keyframes slideIn {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            @keyframes slideInRight {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            @keyframes slideOutRight {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }

            .fixed-height-cell::-webkit-scrollbar {
                width: 6px;
                height: 6px;
            }

            .fixed-height-cell::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.05);
                border-radius: 3px;
            }

            .fixed-height-cell::-webkit-scrollbar-thumb {
                background: rgba(0, 0, 0, 0.2);
                border-radius: 3px;
            }

            .fixed-height-cell::-webkit-scrollbar-thumb:hover {
                background: rgba(0, 0, 0, 0.3);
            }
        `;
        document.head.appendChild(style);
    }

    // ====== æ–°å¢ï¼šrole_idåˆ—ä»…å¤åˆ¶æŒ‰é’®åŠŸèƒ½ ======
    function addRoleIdOnlyCopyButtons() {
        log('info', 'ä¸ºrole_idåˆ—æ·»åŠ ä»…å¤åˆ¶æŒ‰é’®...');

        if (roleIdColumnIndexes.length === 0) {
            findRoleIdColumns();
        }

        roleIdColumnIndexes.forEach(columnIndex => {
            const roleCells = document.querySelectorAll(`.ant-table-tbody > tr > td:nth-child(${columnIndex})`);

            roleCells.forEach((cell, index) => {
                // æ ‡è®°ä¸ºrole_idåˆ—
                cell.setAttribute('data-is-role-id', 'true');

                // æ¸…é™¤ç°æœ‰çš„ä»…å¤åˆ¶æŒ‰é’®
                clearRoleIdOnlyCopyButtons(cell);

                const roleText = getCleanCellText(cell);
                if (roleText && roleText.trim()) {
                    addRoleIdOnlyCopyButton(cell, roleText.trim());
                }
            });
        });
    }

    function clearRoleIdOnlyCopyButtons(cell) {
        const existingBtns = cell.querySelectorAll(`.${ROLE_ID_ONLY_COPY_BTN_CLASS}`);
        existingBtns.forEach(btn => btn.remove());
    }

    function addRoleIdOnlyCopyButton(cell, roleText) {
        // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ç›¸åŒç±»å‹çš„æŒ‰é’®
        if (cell.querySelector(`.${ROLE_ID_ONLY_COPY_BTN_CLASS}`)) return;

        const copyBtn = document.createElement('div');
        copyBtn.className = ROLE_ID_ONLY_COPY_BTN_CLASS;
        copyBtn.title = 'ç‚¹å‡»å¤åˆ¶role_id';
        copyBtn.textContent = '-';

        // æ·»åŠ å”¯ä¸€æ ‡è¯†
        copyBtn.setAttribute('data-button-type', 'role-id-only');

        copyBtn.addEventListener('click', async (e) => {
            e.stopPropagation();

            try {
                await navigator.clipboard.writeText(roleText);
                copyBtn.textContent = 'âœ“';
                copyBtn.classList.add('copied');
                setTimeout(() => {
                    copyBtn.textContent = '-';
                    copyBtn.classList.remove('copied');
                }, 1000);
            } catch (err) {
                log('warn', 'å¤åˆ¶role_idå¤±è´¥:', err);
                copyBtn.textContent = 'âœ—';
                copyBtn.classList.add('error');
                setTimeout(() => {
                    copyBtn.textContent = '-';
                    copyBtn.classList.remove('error');
                }, 1000);
            }
        });

        cell.style.position = 'relative';
        cell.appendChild(copyBtn);
    }

    // ====== æ™ºèƒ½æŒ‰é’®é«˜åº¦é€‚é…åŠŸèƒ½ ======
    function initButtonHeightAdapter() {
        log('info', 'åˆå§‹åŒ–æ™ºèƒ½æŒ‰é’®é«˜åº¦é€‚é…åŠŸèƒ½...');

        setTimeout(() => {
            if (BUTTON_ADAPTER_CONFIG.isEnabled) {
                initialButtonScan();
                setInterval(periodicButtonCheck, BUTTON_ADAPTER_CONFIG.checkInterval);

                buttonAdapterObserver = new MutationObserver((mutations) => {
                    let shouldCheck = false;
                    mutations.forEach(mutation => {
                        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                            shouldCheck = true;
                        }
                    });
                    if (shouldCheck) {
                        setTimeout(() => {
                            if (BUTTON_ADAPTER_CONFIG.isEnabled) {
                                periodicButtonCheck();
                            }
                        }, 100);
                    }
                });

                buttonAdapterObserver.observe(document.body, {
                    childList: true,
                    subtree: true
                });
            }
        }, 1500);
    }

    function isTargetButton(button) {
        if (!button || !button.textContent) return false;
        const text = button.textContent.trim();
        return BUTTON_ADAPTER_CONFIG.targetButtonTexts.some(targetText =>
            text === targetText || text.includes(targetText)
        );
    }

    function getButtonRow(button) {
        let row = button.closest('tr');
        if (row) return row;

        row = button.closest('td.ant-table-cell');
        if (row) {
            const columnIndex = Array.from(row.parentElement.children).indexOf(row) + 1;
            if (columnIndex >= COLUMN_INDEX) {
                return row.parentElement;
            }
        }

        row = button.closest('.ant-space-item');
        if (row) {
            const spaceContainer = row.closest('.ant-space');
            if (spaceContainer) {
                return spaceContainer;
            }
            return row;
        }

        row = button.closest('.ant-row, .ant-btn-group, [class*="row"], [class*="grid"]');
        if (row) return row;

        return null;
    }

    function adaptButtonHeight(button) {
        if (!button || processedButtons.has(button) || !isTargetButton(button) || !BUTTON_ADAPTER_CONFIG.isEnabled) return;

        try {
            const row = getButtonRow(button);
            if (!row) return;

            const targetCell = row.querySelector(`td:nth-child(${COLUMN_INDEX})`);
            if (targetCell) {
                const isTranslated = targetCell.dataset.translated === 'true';
                const hasTranslation = targetCell.querySelector('.translation');

                if (isTranslationEnabled && !isTranslated && !hasTranslation) {
                    if (!pendingButtonAdaptations.has(button)) {
                        pendingButtonAdaptations.set(button, 0);
                    }

                    const retryCount = pendingButtonAdaptations.get(button);
                    if (retryCount < BUTTON_ADAPTER_CONFIG.maxRetryCount) {
                        pendingButtonAdaptations.set(button, retryCount + 1);
                        setTimeout(() => {
                            adaptButtonHeight(button);
                        }, BUTTON_ADAPTER_CONFIG.translationWaitTime);
                        return;
                    }
                }
            }

            pendingButtonAdaptations.delete(button);

            const isSingleColumn = isSingleColumnText(row);

            if (isSingleColumn) {
                const minHeight = BUTTON_ADAPTER_CONFIG.minButtonHeight;
                button.style.height = minHeight + 'px';
                button.style.minHeight = 'auto';
                button.style.lineHeight = minHeight + 'px';
                button.style.maxHeight = 'none';

                button.setAttribute('data-height-adapted', 'true');
                processedButtons.add(button);
                return;
            }

            let referenceHeight = null;
            let maxRowHeight = 0;

            if (targetCell) {
                const cellContainer = targetCell.querySelector('.fixed-height-cell');
                if (cellContainer) {
                    referenceHeight = cellContainer.scrollHeight;

                    if (cellContainer.scrollHeight > MAX_CELL_HEIGHT) {
                        referenceHeight = cellContainer.scrollHeight;
                    }

                    if (PERFORMANCE_CONFIG.logLevel === 'debug') {
                        log('debug', `ç¬¬8åˆ—é«˜åº¦: ${referenceHeight}px, æœ€å¤§é«˜åº¦: ${MAX_CELL_HEIGHT}px`);
                    }
                }
            }

            const allCells = row.querySelectorAll('td.ant-table-cell');
            allCells.forEach(cell => {
                const cellHeight = cell.scrollHeight || cell.offsetHeight;
                maxRowHeight = Math.max(maxRowHeight, cellHeight);
            });

            if (!referenceHeight) {
                const textElements = Array.from(row.querySelectorAll('span, div, p, td:not(.ant-table-cell), .ant-table-cell > *')).filter(el => {
                    return el.offsetWidth > 0 && el.offsetHeight > 0 &&
                           el !== button &&
                           el.style.display !== 'none' &&
                           el.getAttribute('data-height-adapted') !== 'true' &&
                           !el.classList.contains('ant-btn') &&
                           el.textContent.trim().length > 0;
                });

                if (textElements.length === 0) return;

                const heights = textElements.map(el => {
                    return el.scrollHeight || el.offsetHeight;
                });
                referenceHeight = Math.max(...heights);
            }

            let targetHeight;
            if (maxRowHeight > 0 && maxRowHeight > referenceHeight) {
                targetHeight = maxRowHeight - 4;
            } else {
                targetHeight = referenceHeight + BUTTON_ADAPTER_CONFIG.buttonHeightOffset;
            }

            targetHeight = Math.max(
                BUTTON_ADAPTER_CONFIG.minButtonHeight,
                Math.min(BUTTON_ADAPTER_CONFIG.maxButtonHeight, targetHeight)
            );

            const currentHeight = button.getBoundingClientRect().height;
            if (Math.abs(targetHeight - currentHeight) < BUTTON_ADAPTER_CONFIG.minHeightThreshold) {
                return;
            }

            button.style.height = targetHeight + 'px';
            button.style.minHeight = 'auto';
            button.style.lineHeight = targetHeight + 'px';
            button.style.maxHeight = 'none';

            button.setAttribute('data-height-adapted', 'true');
            processedButtons.add(button);
            performanceStats.buttonsAdapted++;

            if (PERFORMANCE_CONFIG.logLevel === 'debug') {
                log('debug', `æŒ‰é’® "${button.textContent}" é«˜åº¦é€‚é…ä¸º: ${targetHeight}px`);
            }

        } catch (error) {
            log('warn', 'æŒ‰é’®é«˜åº¦é€‚é…å‡ºé”™:', error);
        }
    }

    function isSingleColumnText(row) {
        try {
            const allCells = row.querySelectorAll('td.ant-table-cell');
            if (allCells.length === 0) return false;

            let contentColumnCount = 0;
            let hasSignificantContent = false;
            let col8HasContent = false;

            allCells.forEach((cell, index) => {
                const cellText = getCleanCellText(cell);
                const hasContainer = cell.querySelector('.fixed-height-cell');

                if (cellText && cellText.trim().length > 0) {
                    const trimmedText = cellText.trim();
                    if (trimmedText.length > 0) {
                        contentColumnCount++;
                        if (index + 1 === COLUMN_INDEX && hasContainer) {
                            hasSignificantContent = true;
                            col8HasContent = true;
                        }
                    }
                }
            });

            const isSingleColumn = contentColumnCount === BUTTON_ADAPTER_CONFIG.singleColumnThreshold &&
                                  hasSignificantContent &&
                                  col8HasContent &&
                                  contentColumnCount === 1;

            return isSingleColumn;
        } catch (error) {
            log('warn', 'å•åˆ—æ–‡æœ¬æ£€æµ‹å‡ºé”™:', error);
            return false;
        }
    }

    function initialButtonScan() {
        log('info', 'å¼€å§‹æ™ºèƒ½æŒ‰é’®é«˜åº¦é€‚é…æ‰«æ...');
        processAllTargetButtons();
    }

    function periodicButtonCheck() {
        if (!BUTTON_ADAPTER_CONFIG.isEnabled) return;
        processAllTargetButtons();
    }

    function processAllTargetButtons() {
        if (!BUTTON_ADAPTER_CONFIG.isEnabled) return;

        const allButtons = document.querySelectorAll(BUTTON_ADAPTER_CONFIG.targetButtons);
        let processedCount = 0;

        allButtons.forEach(button => {
            if (isTargetButton(button) && !processedButtons.has(button)) {
                adaptButtonHeight(button);
                processedCount++;
            }
        });

        if (processedCount > 0 && PERFORMANCE_CONFIG.logLevel === 'info') {
            log('info', `é€‚é…äº† ${processedCount} ä¸ªæŒ‰é’®çš„é«˜åº¦`);
        }
    }

    function scheduleButtonAdaptationForRow(row) {
        if (!row || !BUTTON_ADAPTER_CONFIG.isEnabled) return;

        setTimeout(() => {
            const buttons = row.querySelectorAll(BUTTON_ADAPTER_CONFIG.targetButtons);
            buttons.forEach(button => {
                if (isTargetButton(button) && !processedButtons.has(button)) {
                    adaptButtonHeight(button);
                }
            });
        }, BUTTON_ADAPTER_CONFIG.translationWaitTime);
    }

    // ====== ä¿®å¤çš„ç¿»è¯‘åº”ç”¨å‡½æ•° ======
    function applyTranslation(cell, originalText, translatedText) {
        const container = cell.querySelector('.fixed-height-cell');
        if (!container) return;

        container.innerHTML = '';

        const originalSpan = document.createElement('span');
        originalSpan.className = 'original';
        originalSpan.textContent = originalText;

        const translationSpan = document.createElement('span');
        translationSpan.className = 'translation';
        translationSpan.textContent = translatedText;
        translationSpan.style.fontWeight = 'bold';

        container.appendChild(originalSpan);
        container.appendChild(translationSpan);

        cell.dataset.translated = 'true';
        adjustFontSizeForCell(cell);
        performanceStats.translationsCompleted++;

        const row = cell.closest('tr');
        if (row && BUTTON_ADAPTER_CONFIG.isEnabled) {
            setTimeout(() => {
                const buttons = row.querySelectorAll(BUTTON_ADAPTER_CONFIG.targetButtons);
                buttons.forEach(button => {
                    if (isTargetButton(button)) {
                        processedButtons.delete(button);
                        button.removeAttribute('data-height-adapted');
                        adaptButtonHeight(button);
                    }
                });
            }, 100);
        }
    }

    // ====== ä¿®å¤çš„role_idåˆ—æŸ¥æ‰¾å‡½æ•° ======
    function findRoleIdColumns() {
        const headers = document.querySelectorAll('.ant-table-thead th');
        roleIdColumnIndexes = [];

        headers.forEach((header, index) => {
            const text = getCleanCellText(header);
            if (text && (text.toLowerCase().includes('role_id') ||
                         text.toLowerCase().includes('role_id2') ||
                         text.toLowerCase().includes('role id') ||
                         text.toLowerCase().includes('roleid'))) {
                const columnIndex = Array.from(header.parentElement.children).indexOf(header) + 1;
                // è·³è¿‡ç¬¬8åˆ—ï¼Œé¿å…é‡å¤æ·»åŠ æŒ‰é’®
                if (columnIndex !== COLUMN_INDEX && !roleIdColumnIndexes.includes(columnIndex)) {
                    roleIdColumnIndexes.push(columnIndex);
                    log('debug', `å‘ç°role_idç›¸å…³åˆ—: "${text}" -> åˆ—ç´¢å¼• ${columnIndex}`);
                }
            }
        });

        log('info', 'å‘ç°role_idåˆ—:', roleIdColumnIndexes);
    }

    // ====== ä¿®å¤çš„role_idåˆ—å¤åˆ¶æŒ‰é’®åŠŸèƒ½ ======
    function addCopyButtonsToRoleIdColumns() {
        if (roleIdColumnIndexes.length === 0) return;

        roleIdColumnIndexes.forEach(columnIndex => {
            const roleCells = document.querySelectorAll(`.ant-table-tbody > tr > td:nth-child(${columnIndex})`);
            roleCells.forEach(cell => {
                // æ¸…é™¤ç°æœ‰çš„roleå¤åˆ¶æŒ‰é’®
                clearRoleCopyButtons(cell);

                if (getCleanCellText(cell)) {
                    addRoleCopyButton(cell, columnIndex);
                }
            });
        });
    }

    // æ¸…é™¤å•å…ƒæ ¼å†…æ‰€æœ‰roleå¤åˆ¶æŒ‰é’®
    function clearRoleCopyButtons(cell) {
        const existingBtns = cell.querySelectorAll(`.${ROLE_COPY_BTN_CLASS}`);
        existingBtns.forEach(btn => btn.remove());
    }

    function addRoleCopyButton(cell, columnIndex) {
        // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ç›¸åŒç±»å‹çš„æŒ‰é’®
        if (cell.querySelector(`.${ROLE_COPY_BTN_CLASS}`)) return;

        const copyBtn = document.createElement('div');
        copyBtn.className = ROLE_COPY_BTN_CLASS;
        copyBtn.title = 'ç‚¹å‡»å¤åˆ¶ç¬¬8åˆ—åŸæ–‡å’Œrole_id';
        copyBtn.textContent = '+';

        // æ·»åŠ å”¯ä¸€æ ‡è¯†
        copyBtn.setAttribute('data-button-type', 'role');

        copyBtn.addEventListener('click', async (e) => {
            e.stopPropagation();

            const row = cell.closest('tr');
            const col8Cell = row.querySelector(`td:nth-child(${COLUMN_INDEX})`);
            let col8Text = '';

            if (col8Cell) {
                const originalText = col8Cell.dataset.originalText;
                if (originalText) {
                    col8Text = originalText;
                } else {
                    const container = col8Cell.querySelector('.fixed-height-cell');
                    if (container) {
                        const originalSpan = container.querySelector('.original');
                        col8Text = originalSpan ? originalSpan.textContent : getCleanCellText(col8Cell);
                    } else {
                        col8Text = getCleanCellText(col8Cell);
                    }
                }
            }

            let roleText = getCleanCellText(cell);
            roleText = roleText.replace('+', '').trim();

            if (!col8Text && !roleText) return;

            const combinedText = col8Text + '\n' + roleText;

            try {
                await navigator.clipboard.writeText(combinedText);
                copyBtn.textContent = 'âœ“';
                copyBtn.classList.add('copied');
                setTimeout(() => {
                    copyBtn.textContent = '+';
                    copyBtn.classList.remove('copied');
                }, 1000);
            } catch (err) {
                log('warn', 'å¤åˆ¶å¤±è´¥:', err);
                copyBtn.textContent = 'âœ—';
                copyBtn.classList.add('error');
                setTimeout(() => {
                    copyBtn.textContent = '+';
                    copyBtn.classList.remove('error');
                }, 1000);
            }
        });

        cell.style.position = 'relative';
        cell.appendChild(copyBtn);
    }

    function getCleanCellText(cell) {
        if (!cell) return '';

        const clone = cell.cloneNode(true);
        const buttons = clone.querySelectorAll('button, .copy-original-btn, .copy-role-combined-btn, .copy-role-id-only-btn');
        buttons.forEach(btn => btn.remove());

        return clone.textContent.trim();
    }

    // ====== ä¿®å¤çš„å•å…ƒæ ¼å¤„ç†å‡½æ•° ======
    function wrapCellContent(cell) {
        const columnIndex = Array.from(cell.parentElement.children).indexOf(cell) + 1;
        if (columnIndex !== COLUMN_INDEX) {
            return;
        }

        const text = getCleanCellText(cell);
        if (!text) return;

        delete cell.dataset.originalText;
        delete cell.dataset.translated;
        delete cell.dataset.processed;
        cell.innerHTML = '';

        cell.dataset.originalText = text;

        const container = document.createElement('div');
        container.className = 'fixed-height-cell';

        const originalSpan = document.createElement('span');
        originalSpan.className = 'original';
        originalSpan.textContent = text;

        container.appendChild(originalSpan);
        cell.appendChild(container);

        addCopyButtonToCell(cell);

        setTimeout(() => {
            setupClickForLongText(cell);
        }, 50);
    }

    // ====== ä¿®å¤çš„ç¬¬8åˆ—å¤åˆ¶æŒ‰é’®å¤„ç† ======
    function addCopyButtonToCell(cell) {
        const columnIndex = Array.from(cell.parentElement.children).indexOf(cell) + 1;
        if (columnIndex !== COLUMN_INDEX) {
            return;
        }

        const cellKey = getCellKey(cell);

        // æ£€æŸ¥æ˜¯å¦å·²ç»å¤„ç†è¿‡è¿™ä¸ªå•å…ƒæ ¼
        if (processedCopyButtons.has(cellKey)) {
            // å¦‚æœå·²ç»å¤„ç†è¿‡ï¼Œç¡®ä¿åªæœ‰ä¸€ä¸ªæŒ‰é’®
            const existingBtns = cell.querySelectorAll(`.${COPY_BTN_CLASS}`);
            if (existingBtns.length > 1) {
                // ä¿ç•™ç¬¬ä¸€ä¸ªï¼Œåˆ é™¤å¤šä½™çš„
                for (let i = 1; i < existingBtns.length; i++) {
                    existingBtns[i].remove();
                }
            }
            return;
        }

        // æ¸…é™¤ç°æœ‰çš„å¤åˆ¶æŒ‰é’®
        const existingBtns = cell.querySelectorAll(`.${COPY_BTN_CLASS}`);
        existingBtns.forEach(btn => btn.remove());

        const copyBtn = document.createElement('div');
        copyBtn.className = COPY_BTN_CLASS;
        copyBtn.title = 'ç‚¹å‡»å¤åˆ¶åŸæ–‡';
        copyBtn.textContent = '+';

        // æ·»åŠ å”¯ä¸€æ ‡è¯†
        copyBtn.setAttribute('data-button-type', 'original');

        copyBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const originalText = cell.dataset.originalText || getCleanCellText(cell);
            if (!originalText) return;
            try {
                await navigator.clipboard.writeText(originalText);
                copyBtn.textContent = 'âœ“';
                copyBtn.classList.add('copied');
                setTimeout(() => {
                    copyBtn.textContent = '+';
                    copyBtn.classList.remove('copied');
                }, 1000);
            } catch (err) {
                log('warn', 'å¤åˆ¶å¤±è´¥:', err);
                copyBtn.textContent = 'âœ—';
                copyBtn.classList.add('error');
                setTimeout(() => {
                    copyBtn.textContent = '+';
                    copyBtn.classList.remove('error');
                }, 1000);
            }
        });

        cell.style.position = 'relative';
        cell.appendChild(copyBtn);

        processedCopyButtons.add(cellKey);
    }

    // ====== ä¿®å¤çš„å­—ä½“è°ƒæ•´å‡½æ•° ======
    async function adjustFontSizeForCell(cell) {
        const columnIndex = Array.from(cell.parentElement.children).indexOf(cell) + 1;
        if (columnIndex !== COLUMN_INDEX) {
            return;
        }

        const container = cell.querySelector('.fixed-height-cell');
        if (!container) return;

        if (container.classList.contains(EXPANDED_CLASS)) {
            container.style.fontSize = '16px';
            return;
        }

        let displayText = '';
        const originalSpan = container.querySelector('.original');
        const translationSpan = container.querySelector('.translation');

        if (originalSpan) displayText += originalSpan.textContent;
        if (translationSpan) displayText += ' ' + translationSpan.textContent;
        if (!displayText.trim()) displayText = cell.dataset.originalText || '';

        const tempElement = document.createElement('div');
        tempElement.style.cssText = `
            position: absolute;
            left: -9999px;
            top: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.1;
            padding: 4px 6px;
            margin: 0;
            box-sizing: border-box;
            width: ${container.clientWidth}px;
            visibility: hidden;
        `;

        if (originalSpan && translationSpan) {
            const tempOriginal = document.createElement('span');
            tempOriginal.style.fontWeight = 'normal';
            tempOriginal.style.display = 'inline';
            tempOriginal.textContent = originalSpan.textContent;

            const tempTranslation = document.createElement('span');
            tempTranslation.style.fontWeight = 'bold';
            tempTranslation.style.display = 'inline';
            tempTranslation.style.marginLeft = '8px';
            tempTranslation.textContent = translationSpan.textContent;

            tempElement.appendChild(tempOriginal);
            tempElement.appendChild(tempTranslation);
        } else {
            tempElement.textContent = displayText;
        }

        document.body.appendChild(tempElement);

        let fontSize = MAX_FONT_SIZE;
        tempElement.style.fontSize = `${fontSize}px`;
        let contentHeight = tempElement.scrollHeight;

        const computedStyle = window.getComputedStyle(tempElement);
        const lineHeight = parseFloat(computedStyle.lineHeight) || fontSize * 1.1;
        const approxLines = lineHeight > 0 ? Math.ceil(contentHeight / lineHeight) : 1;
        const charCount = displayText.length;

        if (charCount <= SINGLE_LINE_CHAR_LIMIT && approxLines === 1) {
            container.classList.add('single-line');
            let optimalSize = MAX_FONT_SIZE;
            while (optimalSize > MIN_FONT_SIZE) {
                tempElement.style.fontSize = `${optimalSize}px`;
                const currentHeight = tempElement.scrollHeight;
                const currentLines = lineHeight > 0 ? Math.ceil(currentHeight / lineHeight) : 1;
                if (currentHeight <= SINGLE_LINE_HEIGHT && currentLines === 1) {
                    let tryLarger = Math.min(MAX_FONT_SIZE, optimalSize + 4);
                    while (tryLarger > optimalSize) {
                        tempElement.style.fontSize = `${tryLarger}px`;
                        const largerHeight = tempElement.scrollHeight;
                        const largerLines = lineHeight > 0 ? Math.ceil(largerHeight / lineHeight) : 1;
                        if (largerHeight <= SINGLE_LINE_HEIGHT && largerLines === 1) {
                            optimalSize = tryLarger;
                        }
                        tryLarger--;
                    }
                    break;
                }
                optimalSize--;
            }
            fontSize = optimalSize;
        } else {
            container.classList.remove('single-line');
            if (approxLines <= 2) {
                let optimalSize = MAX_FONT_SIZE;
                while (optimalSize > MIN_FONT_SIZE) {
                    tempElement.style.fontSize = `${optimalSize}px`;
                    if (tempElement.scrollHeight <= MAX_CELL_HEIGHT) {
                        let tryLarger = Math.min(MAX_FONT_SIZE, optimalSize + 2);
                        while (tryLarger > optimalSize) {
                            tempElement.style.fontSize = `${tryLarger}px`;
                            if (tempElement.scrollHeight <= MAX_CELL_HEIGHT) {
                                optimalSize = tryLarger;
                            }
                            tryLarger--;
                        }
                        break;
                    }
                    optimalSize--;
                }
                fontSize = optimalSize;
            } else {
                while (fontSize > MIN_FONT_SIZE) {
                    fontSize--;
                    tempElement.style.fontSize = `${fontSize}px`;
                    contentHeight = tempElement.scrollHeight;
                    if (contentHeight <= MAX_CELL_HEIGHT) break;
                }
                if (fontSize < MIN_FONT_SIZE) {
                    fontSize = MIN_FONT_SIZE;
                    tempElement.style.fontSize = `${fontSize}px`;
                    if (tempElement.scrollHeight > MAX_CELL_HEIGHT) {
                        log('warn', 'è­¦å‘Š: å³ä½¿ä½¿ç”¨æœ€å°å­—ä½“ï¼Œæ–‡æœ¬ä»ç„¶è¶…å‡ºæœ€å¤§é«˜åº¦');
                    }
                }
            }
        }

        container.style.fontSize = `${fontSize}px`;
        document.body.removeChild(tempElement);

        updateScrollbarVisibility(container, charCount, approxLines);
    }

    function updateScrollbarVisibility(container, charCount, approxLines) {
        setTimeout(() => {
            if (container.classList.contains(EXPANDED_CLASS)) {
                container.classList.add('no-scroll');
                return;
            }

            if (charCount <= SINGLE_LINE_CHAR_LIMIT && approxLines === 1) {
                container.classList.add('no-scroll');
            } else {
                const hasScroll = container.scrollHeight > MAX_CELL_HEIGHT + 5;
                container.classList.toggle('no-scroll', !hasScroll);

                const cell = container.closest('td');
                if (cell) {
                    setupClickForLongText(cell);
                }
            }
        }, 30);
    }

    // ====== ä¿®å¤çš„ç¿»è¯‘å‡½æ•° ======
    async function translateIfNeeded(cell) {
        const columnIndex = Array.from(cell.parentElement.children).indexOf(cell) + 1;
        if (columnIndex !== COLUMN_INDEX) {
            return;
        }

        const originalText = cell.dataset.originalText || '';
        if (!originalText || originalText.length < 3) return;
        if (cell.dataset.translated === 'true') return;

        if (translationCache.has(originalText)) {
            applyTranslation(cell, originalText, translationCache.get(originalText));
            return;
        }

        try {
            const translatedText = await translateText(originalText);
            if (translatedText && translatedText !== originalText) {
                translationCache.set(originalText, translatedText);
                applyTranslation(cell, originalText, translatedText);
            }
        } catch (e) {
            log('warn', 'ç¿»è¯‘å¤±è´¥:', e);
        }
    }

    function setupClickForLongText(cell) {
        const container = cell.querySelector('.fixed-height-cell');
        if (!container) return;

        const needsScroll = container.scrollHeight > MAX_CELL_HEIGHT + 5;

        if (needsScroll) {
            container.classList.add('long-text');

            container.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFullDisplay(cell);
            });
        } else {
            container.classList.remove('long-text');
            container.replaceWith(container.cloneNode(true));
        }
    }

    function toggleFullDisplay(cell) {
        const container = cell.querySelector('.fixed-height-cell');
        if (!container) return;

        const isExpanded = container.classList.contains(EXPANDED_CLASS);

        if (isExpanded) {
            container.classList.remove(EXPANDED_CLASS);
            adjustFontSizeForCell(cell);
        } else {
            container.classList.add(EXPANDED_CLASS);
            container.style.fontSize = '16px';
        }
    }

    async function translateText(text) {
        return new Promise((resolve) => {
            const url = 'https://translate.googleapis.com/translate_a/single';
            const params = new URLSearchParams({
                client: 'gtx',
                sl: 'auto',
                tl: 'zh-CN',
                dt: 't',
                q: text
            });
            GM_xmlhttpRequest({
                method: 'GET',
                url: `${url}?${params}`,
                timeout: 8000,
                onload: res => {
                    if (res.status === 200) {
                        try {
                            const data = JSON.parse(res.responseText);
                            let result = '';
                            if (Array.isArray(data) && Array.isArray(data[0])) {
                                for (const item of data[0]) {
                                    if (item?.[0]) result += item[0];
                                }
                            }
                            resolve(result || text);
                        } catch (e) {
                            resolve(text);
                        }
                    } else {
                        resolve(text);
                    }
                },
                onerror: () => resolve(text),
                ontimeout: () => resolve(text)
            });
        });
    }

    function setupTableSortDetection() {
        tableMutationObserver = new MutationObserver((mutations) => {
            let shouldProcess = false;

            for (const mutation of mutations) {
                if (mutation.type === 'childList') {
                    for (const node of mutation.addedNodes) {
                        if (node.nodeType === 1) {
                            if (node.matches && (
                                node.matches('.ant-table-tbody') ||
                                node.matches('.ant-table-tbody tr') ||
                                node.matches('.ant-table') ||
                                node.querySelector('.ant-table-tbody')
                            )) {
                                shouldProcess = true;
                                break;
                            }
                        }
                    }
                }
            }

            if (shouldProcess) {
                log('debug', 'æ£€æµ‹åˆ°è¡¨æ ¼æ›´æ–°ï¼Œé‡æ–°å¤„ç†...');
                scheduleProcessNewCells();
                setTimeout(() => {
                    findRoleIdColumns();
                    addCopyButtonsToRoleIdColumns();
                    addRoleIdOnlyCopyButtons(); // æ·»åŠ role_idåˆ—ä»…å¤åˆ¶æŒ‰é’®
                }, 500);
            }
        });

        tableMutationObserver.observe(document.body, {
            childList: true,
            subtree: true
        });
    }

    function bindShortcut() {
        log('info', 'ç»‘å®šå¿«æ·é”®ç›‘å¬å™¨');

        function handleKeyDown(e) {
            if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.contentEditable === 'true')) {
                return;
            }

            if (e.altKey && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                e.stopPropagation();
                log('debug', 'Alt+Z è§¦å‘ - åˆ‡æ¢ç¿»è¯‘åŠŸèƒ½');
                toggleTranslation();
                return;
            }

            if (e.key === '=' || e.code === 'Equal') {
                e.preventDefault();
                e.stopPropagation();
                log('debug', '= é”®è§¦å‘ - åˆ‡æ¢æŒ‰é’®é«˜åº¦é€‚é…');
                toggleButtonHeightAdapter();
                return;
            }

            if (e.key === '-' || e.code === 'Minus') {
                e.preventDefault();
                e.stopPropagation();
                log('debug', '- é”®è§¦å‘ - å¼€å…³æ§åˆ¶é¢æ¿');
                toggleControlPanel();
                return;
            }
        }

        document.addEventListener('keydown', handleKeyDown, true);
        window.addEventListener('keydown', handleKeyDown, true);
    }

    function toggleTranslation() {
        isTranslationEnabled = !isTranslationEnabled;
        saveSettings();

        if (typeof GM_notification !== 'undefined') {
            GM_notification({
                text: `ç¿»è¯‘å·²${isTranslationEnabled ? 'å¼€å¯' : 'å…³é—­'}`,
                timeout: 2000
            });
        } else {
            showNotification(`ç¿»è¯‘å·²${isTranslationEnabled ? 'å¼€å¯' : 'å…³é—­'}`, 'info');
        }

        if (controlPanel) {
            const translationToggle = controlPanel.querySelector('#translation-toggle');
            if (translationToggle) {
                translationToggle.checked = isTranslationEnabled;
            }
        }

        if (isTranslationEnabled) {
            reprocessTranslationsOnly();
        } else {
            removeTranslationsOnly();
        }
    }

    function toggleButtonHeightAdapter() {
        BUTTON_ADAPTER_CONFIG.isEnabled = !BUTTON_ADAPTER_CONFIG.isEnabled;
        saveSettings();

        if (typeof GM_notification !== 'undefined') {
            GM_notification({
                text: `æŒ‰é’®é«˜åº¦é€‚é…å·²${BUTTON_ADAPTER_CONFIG.isEnabled ? 'å¼€å¯' : 'å…³é—­'}`,
                timeout: 2000
            });
        } else {
            showNotification(`æŒ‰é’®é«˜åº¦é€‚é…å·²${BUTTON_ADAPTER_CONFIG.isEnabled ? 'å¼€å¯' : 'å…³é—­'}`, 'info');
        }

        if (controlPanel) {
            const buttonHeightToggle = controlPanel.querySelector('#button-height-adapter-toggle');
            if (buttonHeightToggle) {
                buttonHeightToggle.checked = BUTTON_ADAPTER_CONFIG.isEnabled;
            }
        }

        if (BUTTON_ADAPTER_CONFIG.isEnabled) {
            processedButtons.clear();
            pendingButtonAdaptations.clear();
            initialButtonScan();
        } else {
            processedButtons.clear();
            pendingButtonAdaptations.clear();
            document.querySelectorAll('button[data-height-adapted="true"]').forEach(btn => {
                btn.removeAttribute('data-height-adapted');
                btn.style.height = '';
                btn.style.minHeight = '';
                btn.style.lineHeight = '';
                btn.style.maxHeight = '';
            });
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();
