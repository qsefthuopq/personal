// ==UserScript==
// @name         å·¥ä½œå°æ–‡æœ¬ç¿»è¯‘|å¤åˆ¶æŒ‰é’®|è‡ªåŠ¨ç¼©æ”¾|æ€§èƒ½ä¿®å¤å®Œæ•´ç‰ˆ
// @namespace    http://tampermonkey.net/
// @version      8.2.0
// @description  åŸºäºåŸç‰ˆä¿®å¤ï¼šè§£å†³Ant-Popoverå¡é¡¿ï½œä¿®å¤ç›¸åŒå†…å®¹å¤„ç†ï½œä¿®å¤å¤åˆ¶æŒ‰é’®ï½œä¿ç•™æ‰€æœ‰åŸåŠŸèƒ½
// @author       You
// @match        https://breeze.opd.easebar.com/*
// @grant        GM_xmlhttpRequest
// @grant        GM_notification
// @grant        GM_getValue
// @grant        GM_setValue
// @connect      translate.googleapis.com
// @run-at       document-idle
// ==/UserScript==

(function () {
    'use strict';

    // ====== é…ç½® (ä¿æŒåŸç‰ˆ) ======
    const COLUMN_INDEX = 8; // åªå¤„ç†ç¬¬8åˆ—
    let MIN_FONT_SIZE = 16;
    let MAX_FONT_SIZE = 32;
    const MAX_CELL_HEIGHT = 165;
    const SINGLE_LINE_HEIGHT = 50;
    const BATCH_SIZE = 25;
    let SINGLE_LINE_CHAR_LIMIT = 60;
    const COPY_BTN_CLASS = 'copy-original-btn';
    const ROLE_COPY_BTN_CLASS = 'copy-role-combined-btn';
    const ROLE_ID_ONLY_COPY_BTN_CLASS = 'copy-role-id-only-btn'; // role_idåˆ—ä»…å¤åˆ¶æŒ‰é’®
    const EXPANDED_CLASS = 'expanded-full';

    // ====== æ€§èƒ½ä¼˜åŒ–é…ç½® ======
    const PERFORMANCE_CONFIG = {
        logLevel: 'info',
        batchProcessing: true,
        debounceDelay: 500, // å¢åŠ é˜²æŠ–æ—¶é—´ï¼Œå‡å°‘é¢‘ç¹è§¦å‘
        maxProcessingTime: 1000,
        enablePerformanceMonitor: false,
        scrollThrottle: 100,
        maxCellsPerBatch: 50,
        smartScrollEnabled: true
    };

    // ====== æ™ºèƒ½æŒ‰é’®é«˜åº¦é€‚é…é…ç½® (ä¿æŒåŸç‰ˆ) ======
    const BUTTON_ADAPTER_CONFIG = {
        targetButtons: 'button.ant-btn',
        targetButtonTexts: ['Forbid', 'Rename', 'Punish'],
        containerSelector: '.ant-space-item, .ant-space',
        rowSelector: 'td.ant-table-cell, tr',
        transitionDuration: '1ms',
        checkInterval: 500, // é™ä½æ£€æŸ¥é¢‘ç‡
        minHeightThreshold: 1,
        maxButtonHeight: 140,
        minButtonHeight: 20,
        buttonHeightOffset: -18,
        singleColumnThreshold: 1,
        isEnabled: false,
        waitForTranslation: true,
        translationWaitTime: 800,
        maxRetryCount: 3
    };

    let isTranslationEnabled = true;
    const translationCache = new Map();
    let processing = false;
    let processDebounceTimer = null;
    let roleIdColumnIndexes = [];
    let observer = null;
    let tableMutationObserver = null;

    // ====== æ€§èƒ½ä¼˜åŒ–æ–°å¢ï¼šå…¨å±€æµ‹é‡å®¹å™¨ ======
    let globalMeasureContainer = null;

    // ====== æŒ‰é’®é«˜åº¦é€‚é…ç›¸å…³å˜é‡ ======
    // ä¼˜åŒ–ï¼šä½¿ç”¨WeakSeté˜²æ­¢å†…å­˜æ³„æ¼
    const processedButtons = new WeakSet();
    let buttonAdapterObserver = null;
    // ä¼˜åŒ–ï¼šç§»é™¤åŸºäºæ–‡æœ¬Keyçš„Setï¼Œæ”¹ç”¨DOMæ ‡è®°ï¼Œè§£å†³ç›¸åŒè¡Œé—®é¢˜
    // const processedCopyButtons = new Set();
    // const processedCells = new Set(); 
    const pendingButtonAdaptations = new WeakMap();

    // ====== æ§åˆ¶é¢æ¿çŠ¶æ€å˜é‡ ======
    let controlPanelMinimized = true;
    let controlPanel = null;
    let minimizeBtn = null;
    let contentContainer = null;
    let panelHeader = null;

    // ====== æ™ºèƒ½æ»šåŠ¨ç›¸å…³å˜é‡ ======
    let scrollHandlersAttached = false;

    // ====== æ€§èƒ½ç›‘æ§ ======
    let performanceStats = {
        cellsProcessed: 0,
        translationsCompleted: 0,
        buttonsAdapted: 0,
        startTime: 0
    };

    // ====== æ—¥å¿—å‡½æ•° ======
    function log(level, message, data) {
        const levels = { debug: 0, info: 1, warn: 2, error: 3 };
        const currentLevel = levels[PERFORMANCE_CONFIG.logLevel] || 1;
        const messageLevel = levels[level] || 1;

        if (messageLevel >= currentLevel) {
            if (data) {
                console[level](`ğŸ”§ ${message}`, data);
            } else {
                console[level](`ğŸ”§ ${message}`);
            }
        }
    }

    function init() {
        log('info', `å·¥ä½œå°ç¿»è¯‘ä¸å¤åˆ¶åŠ©æ‰‹ v8.2.0 æ€§èƒ½ä¿®å¤å®Œæ•´ç‰ˆ å·²åŠ è½½`);
        performanceStats.startTime = Date.now();
        loadSettings();
        addGlobalStyle();
        createMeasureContainer(); // åˆå§‹åŒ–æµ‹é‡å®¹å™¨
        bindShortcut();
        startStableMonitoring();
        setupTableSortDetection();
        initButtonHeightAdapter();
        createControlPanel();

        setTimeout(() => {
            initSmartScrollHandling();
        }, 2000);
    }

    // ====== æ–°å¢ï¼šåˆ›å»ºå…¨å±€æµ‹é‡å®¹å™¨ ======
    function createMeasureContainer() {
        if (globalMeasureContainer) return;
        globalMeasureContainer = document.createElement('div');
        globalMeasureContainer.style.cssText = `
            position: absolute;
            left: -9999px;
            top: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.1;
            padding: 4px 6px;
            margin: 0;
            box-sizing: border-box;
            visibility: hidden;
            pointer-events: none;
            z-index: -1000;
        `;
        document.body.appendChild(globalMeasureContainer);
    }

    // ====== ä¿®å¤çš„æ™ºèƒ½æ»šåŠ¨å¤„ç† ======
    function initSmartScrollHandling() {
        if (!PERFORMANCE_CONFIG.smartScrollEnabled || scrollHandlersAttached) {
            return;
        }

        log('info', 'åˆå§‹åŒ–ä¼˜åŒ–çš„æ™ºèƒ½æ»šåŠ¨å¤„ç†...');

        const handleWheelEvent = (e) => {
            // ç®€å•åˆ¤æ–­æ˜¯å¦åœ¨å›ºå®šé«˜åº¦å•å…ƒæ ¼å†…
            let target = e.target;
            let fixedHeightCell = target.closest('.fixed-height-cell');

            if (fixedHeightCell && fixedHeightCell.scrollHeight > fixedHeightCell.clientHeight) {
                // åªæœ‰å½“çœŸçš„éœ€è¦æ»šåŠ¨æ—¶æ‰æ‹¦æˆª
                const atTop = fixedHeightCell.scrollTop === 0;
                const atBottom = Math.abs(fixedHeightCell.scrollHeight - fixedHeightCell.scrollTop - fixedHeightCell.clientHeight) < 1;
                
                const isUp = (e.deltaY || e.detail) < 0;
                const isDown = (e.deltaY || e.detail) > 0;

                // é˜»æ­¢å†’æ³¡é˜²æ­¢é¡µé¢æ»šåŠ¨ï¼Œä½†å…è®¸å†…éƒ¨æ»šåŠ¨
                if ((isUp && !atTop) || (isDown && !atBottom)) {
                    e.stopPropagation();
                }
            }
        };

        const passiveOptions = { passive: false, capture: true };
        document.addEventListener('wheel', handleWheelEvent, passiveOptions);
        document.addEventListener('mousewheel', handleWheelEvent, passiveOptions);

        scrollHandlersAttached = true;
        log('info', 'æ™ºèƒ½æ»šåŠ¨å¤„ç†å·²å¯ç”¨ï¼ˆä¼˜åŒ–ç‰ˆï¼‰');
    }

    function disableSmartScrollHandling() {
        if (!scrollHandlersAttached) return;
        // ç®€åŒ–ç§»é™¤é€»è¾‘
        scrollHandlersAttached = false;
    }

    // ====== åŠ è½½è®¾ç½® (ä¿æŒåŸç‰ˆ) ======
    function loadSettings() {
        try {
            const savedMinFontSize = GM_getValue('minFontSize');
            const savedMaxFontSize = GM_getValue('maxFontSize');
            const savedCharLimit = GM_getValue('charLimit');
            const savedTranslationEnabled = GM_getValue('translationEnabled');
            const savedButtonAdapterEnabled = GM_getValue('buttonAdapterEnabled');
            const savedPanelMinimized = GM_getValue('panelMinimized');
            const savedSmartScrollEnabled = GM_getValue('smartScrollEnabled');

            if (savedMinFontSize !== undefined) MIN_FONT_SIZE = savedMinFontSize;
            if (savedMaxFontSize !== undefined) MAX_FONT_SIZE = savedMaxFontSize;
            if (savedCharLimit !== undefined) SINGLE_LINE_CHAR_LIMIT = savedCharLimit;
            if (savedTranslationEnabled !== undefined) isTranslationEnabled = savedTranslationEnabled;
            if (savedButtonAdapterEnabled !== undefined) BUTTON_ADAPTER_CONFIG.isEnabled = savedButtonAdapterEnabled;
            if (savedPanelMinimized !== undefined) controlPanelMinimized = savedPanelMinimized;
            if (savedSmartScrollEnabled !== undefined) PERFORMANCE_CONFIG.smartScrollEnabled = savedSmartScrollEnabled;
        } catch (error) {
            log('warn', 'åŠ è½½è®¾ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼:', error);
        }
    }

    // ====== ä¿å­˜è®¾ç½® (ä¿æŒåŸç‰ˆ) ======
    function saveSettings() {
        try {
            GM_setValue('minFontSize', MIN_FONT_SIZE);
            GM_setValue('maxFontSize', MAX_FONT_SIZE);
            GM_setValue('charLimit', SINGLE_LINE_CHAR_LIMIT);
            GM_setValue('translationEnabled', isTranslationEnabled);
            GM_setValue('buttonAdapterEnabled', BUTTON_ADAPTER_CONFIG.isEnabled);
            GM_setValue('panelMinimized', controlPanelMinimized);
            GM_setValue('smartScrollEnabled', PERFORMANCE_CONFIG.smartScrollEnabled);
        } catch (error) {
            log('warn', 'ä¿å­˜è®¾ç½®å¤±è´¥:', error);
        }
    }

    // ====== åˆ›å»ºæ§åˆ¶é¢æ¿ (å®Œå…¨ä¿ç•™åŸç‰ˆå¤æ‚é€»è¾‘) ======
    function createControlPanel() {
        controlPanel = document.createElement('div');
        controlPanel.id = 'translation-assistant-control-panel';
        controlPanel.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            padding: 0;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
            font-size: 12px;
            color: #333;
            min-width: 30px;
            width: 30px;
            height: 30px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            overflow: hidden;
        `;

        const miniButton = document.createElement('div');
        miniButton.id = 'control-panel-mini-button';
        miniButton.style.cssText = `
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            color: #1890ff;
            background: rgba(24, 144, 255, 0.1);
            border-radius: 6px;
            transition: all 0.2s ease;
        `;
        miniButton.textContent = '+';
        miniButton.title = 'å±•å¼€æ§åˆ¶é¢æ¿ (å¿«æ·é”®: -)';

        miniButton.addEventListener('click', toggleControlPanel);

        panelHeader = document.createElement('div');
        panelHeader.style.cssText = `
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(24, 144, 255, 0.15) 0%, rgba(24, 144, 255, 0.1) 100%);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px 8px 0 0;
            cursor: move;
        `;

        const title = document.createElement('div');
        title.style.cssText = 'font-weight: bold; color: #1890ff; font-size: 13px;';
        title.textContent = 'ğŸ”§ ç¿»è¯‘åŠ©æ‰‹';

        minimizeBtn = document.createElement('button');
        minimizeBtn.style.cssText = 'background: none; border: none; font-size: 16px; cursor: pointer; padding: 2px 6px; font-weight: bold; color: #666;';
        minimizeBtn.textContent = 'âˆ’';
        minimizeBtn.onclick = toggleControlPanel;

        panelHeader.appendChild(title);
        panelHeader.appendChild(minimizeBtn);

        contentContainer = document.createElement('div');
        contentContainer.style.cssText = 'display: none; padding: 16px; max-height: 400px; overflow-y: auto; background: rgba(255, 255, 255, 0.95);';

        contentContainer.innerHTML = `
            <div style="margin-bottom: 16px;">
                <div style="font-weight: bold; margin-bottom: 8px; color: #333;">åŸºç¡€åŠŸèƒ½</div>
                <div style="margin-bottom: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="translation-toggle" ${isTranslationEnabled ? 'checked' : ''} style="margin-right: 8px;"> å¯ç”¨ç¿»è¯‘åŠŸèƒ½
                    </label>
                </div>
                <div style="margin-bottom: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="button-height-adapter-toggle" ${BUTTON_ADAPTER_CONFIG.isEnabled ? 'checked' : ''} style="margin-right: 8px;"> å¯ç”¨æŒ‰é’®é«˜åº¦é€‚é…
                    </label>
                </div>
                 <div style="margin-bottom: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="smart-scroll-toggle" ${PERFORMANCE_CONFIG.smartScrollEnabled ? 'checked' : ''} style="margin-right: 8px;"> å¯ç”¨æ™ºèƒ½æ»šåŠ¨å…¼å®¹
                    </label>
                </div>
            </div>
            <div style="margin-bottom: 16px;">
                <div style="font-weight: bold; margin-bottom: 8px; color: #333;">å­—ä½“è®¾ç½®</div>
                <div style="margin-bottom: 8px;">
                    <label style="display: block; font-size: 11px; color: #666;">æœ€å°å­—ä½“</label>
                    <input type="number" id="min-font-size" value="${MIN_FONT_SIZE}" min="10" max="24" style="width: 100%; border: 1px solid #ddd; padding: 4px;">
                </div>
                <div style="margin-bottom: 8px;">
                    <label style="display: block; font-size: 11px; color: #666;">æœ€å¤§å­—ä½“</label>
                    <input type="number" id="max-font-size" value="${MAX_FONT_SIZE}" min="20" max="48" style="width: 100%; border: 1px solid #ddd; padding: 4px;">
                </div>
                <div>
                    <label style="display: block; font-size: 11px; color: #666;">å•è¡Œå­—ç¬¦é™åˆ¶</label>
                    <input type="number" id="single-line-char-limit" value="${SINGLE_LINE_CHAR_LIMIT}" min="20" max="120" style="width: 100%; border: 1px solid #ddd; padding: 4px;">
                </div>
            </div>
            <button id="apply-settings-btn" style="width: 100%; padding: 8px; background: #1890ff; color: white; border: none; border-radius: 4px; cursor: pointer;">åº”ç”¨è®¾ç½®</button>
        `;

        controlPanel.appendChild(miniButton);
        controlPanel.appendChild(panelHeader);
        controlPanel.appendChild(contentContainer);
        document.body.appendChild(controlPanel);

        addDragFunctionality(controlPanel, panelHeader);
        bindControlPanelEvents();

        if (controlPanelMinimized) minimizeControlPanel();
        else expandControlPanel();
    }

    function minimizeControlPanel() {
        const miniButton = controlPanel.querySelector('#control-panel-mini-button');
        if (miniButton) miniButton.style.display = 'flex';
        contentContainer.style.display = 'none';
        panelHeader.style.display = 'none';
        controlPanel.style.minWidth = '30px';
        controlPanel.style.width = '30px';
        controlPanel.style.height = '30px';
        controlPanelMinimized = true;
        saveSettings();
    }

    function expandControlPanel() {
        const miniButton = controlPanel.querySelector('#control-panel-mini-button');
        if (miniButton) miniButton.style.display = 'none';
        contentContainer.style.display = 'block';
        panelHeader.style.display = 'flex';
        controlPanel.style.minWidth = '240px';
        controlPanel.style.width = '280px';
        controlPanel.style.height = '';
        controlPanelMinimized = false;
        saveSettings();
    }

    function toggleControlPanel() {
        if (controlPanelMinimized) expandControlPanel();
        else minimizeControlPanel();
    }

    function addDragFunctionality(panel, handle) {
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        handle.onmousedown = (e) => {
            isDragging = true;
            dragOffsetX = e.clientX - panel.offsetLeft;
            dragOffsetY = e.clientY - panel.offsetTop;
            handle.style.cursor = 'grabbing';
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        };

        function handleMouseMove(e) {
            if (isDragging) {
                panel.style.left = (e.clientX - dragOffsetX) + 'px';
                panel.style.top = (e.clientY - dragOffsetY) + 'px';
                panel.style.right = 'auto';
            }
        }

        function handleMouseUp() {
            isDragging = false;
            handle.style.cursor = 'move';
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        }
    }

    function bindControlPanelEvents() {
        const translationToggle = controlPanel.querySelector('#translation-toggle');
        translationToggle.addEventListener('change', (e) => {
            isTranslationEnabled = e.target.checked;
            saveSettings();
            if (isTranslationEnabled) reprocessTranslationsOnly();
            else removeTranslationsOnly();
        });

        const buttonHeightToggle = controlPanel.querySelector('#button-height-adapter-toggle');
        buttonHeightToggle.addEventListener('change', (e) => {
            BUTTON_ADAPTER_CONFIG.isEnabled = e.target.checked;
            saveSettings();
            if (BUTTON_ADAPTER_CONFIG.isEnabled) initialButtonScan();
        });

        const smartScrollToggle = controlPanel.querySelector('#smart-scroll-toggle');
        smartScrollToggle.addEventListener('change', (e) => {
            PERFORMANCE_CONFIG.smartScrollEnabled = e.target.checked;
            saveSettings();
            if(PERFORMANCE_CONFIG.smartScrollEnabled) initSmartScrollHandling();
        });

        const applyBtn = controlPanel.querySelector('#apply-settings-btn');
        applyBtn.addEventListener('click', applySettings);
    }

    function applySettings() {
        MIN_FONT_SIZE = parseInt(controlPanel.querySelector('#min-font-size').value);
        MAX_FONT_SIZE = parseInt(controlPanel.querySelector('#max-font-size').value);
        SINGLE_LINE_CHAR_LIMIT = parseInt(controlPanel.querySelector('#single-line-char-limit').value);
        saveSettings();
        adjustFontSizesOnly();
        showNotification('è®¾ç½®å·²åº”ç”¨', 'success');
    }

    function showNotification(message, type = 'info') {
        if (typeof GM_notification !== 'undefined') {
             GM_notification({ text: message, timeout: 2000 });
        } else {
            // ç®€å•çš„ fallback
            console.log(message);
        }
    }

    // ====== ä¿®å¤çš„ç¨³å®šç›‘æ§ç³»ç»Ÿ (è§£å†³ ant-popover å¡é¡¿) ======
    function startStableMonitoring() {
        log('info', 'å¯åŠ¨ç¨³å®šç›‘æ§ç³»ç»Ÿ...');

        observer = new MutationObserver((mutations) => {
            let shouldProcess = false;

            for (const mutation of mutations) {
                // æ ¸å¿ƒä¿®å¤ï¼šè¿‡æ»¤æ‰ ant-popover, ant-tooltip, ant-dropdown çš„å˜åŠ¨
                const target = mutation.target;
                if (target.nodeType === 1) {
                    if (target.matches('.ant-popover, .ant-tooltip, .ant-dropdown, .ant-select-dropdown') || 
                        target.closest('.ant-popover, .ant-tooltip, .ant-dropdown')) {
                        continue;
                    }
                }

                if (mutation.type === 'childList') {
                    for (const node of mutation.addedNodes) {
                        if (node.nodeType === 1) {
                            // åªå…³æ³¨è¡¨æ ¼ç›¸å…³çš„å˜åŠ¨
                            if (node.matches && (
                                node.matches('.ant-table-tbody') ||
                                node.matches('tr') ||
                                node.querySelector('.ant-table-tbody')
                            )) {
                                shouldProcess = true;
                                break;
                            }
                        }
                    }
                }
                if (shouldProcess) break;
            }

            if (shouldProcess) {
                scheduleProcessNewCells();
                setTimeout(() => {
                    findRoleIdColumns();
                    addCopyButtonsToRoleIdColumns();
                    addRoleIdOnlyCopyButtons();
                }, 500);
            }
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: false // ä¸ç›‘å¬å±æ€§å˜åŒ–ï¼Œæå¤§å‡å°‘è§¦å‘é¢‘ç‡
        });

        setTimeout(() => {
            processAllCellsInBatches();
            findRoleIdColumns();
            addCopyButtonsToRoleIdColumns();
            addRoleIdOnlyCopyButtons();
        }, 1500);
    }

    function processAllCellsInBatches() {
        if (processing) return;
        processing = true;

        // ä¿®å¤ï¼šä¸å†ä½¿ç”¨ Set å»é‡ï¼Œè€Œæ˜¯æ£€æŸ¥ cell çš„ dataset
        // è¿™æ ·å³ä½¿ä¸¤è¡Œå†…å®¹ä¸€æ ·ï¼Œåªè¦å®ƒä»¬æ˜¯ä¸åŒçš„ DOM å…ƒç´ ï¼Œéƒ½ä¼šè¢«é€‰ä¸­
        const allCells = Array.from(document.querySelectorAll(`.ant-table-tbody > tr > td:nth-child(${COLUMN_INDEX})`));
        
        const unprocessed = allCells.filter(cell => {
            // æ£€æŸ¥æ ‡è®°ï¼Œå¦‚æœæœªå¤„ç†è¿‡
            return !cell.dataset.processedV8;
        });

        const cellsToProcess = unprocessed.slice(0, PERFORMANCE_CONFIG.maxCellsPerBatch);

        for (const cell of cellsToProcess) {
            wrapCellContent(cell);
            // æ ‡è®°ä¸ºå·²å¤„ç†
            cell.dataset.processedV8 = 'true';
            performanceStats.cellsProcessed++;
        }

        // å¼‚æ­¥å¤„ç†å­—ä½“å’Œç¿»è¯‘ï¼Œé¿å…é˜»å¡
        setTimeout(() => {
            for (const cell of cellsToProcess) {
                adjustFontSizeForCell(cell);
                if (isTranslationEnabled && cell.dataset.translated !== 'true') {
                    translateIfNeeded(cell);
                }
                if (BUTTON_ADAPTER_CONFIG.isEnabled) {
                    scheduleButtonAdaptationForRow(cell.closest('tr'));
                }
            }
        }, 0);
        
        // å¦‚æœè¿˜æœ‰å‰©ä½™çš„ï¼Œç»§ç»­å¤„ç†
        if (unprocessed.length > cellsToProcess.length) {
            setTimeout(processAllCellsInBatches, 100);
        } else {
             processing = false;
        }
    }

    function scheduleProcessNewCells() {
        if (processDebounceTimer) clearTimeout(processDebounceTimer);
        processDebounceTimer = setTimeout(() => {
            processAllCellsInBatches();
        }, PERFORMANCE_CONFIG.debounceDelay);
    }

    function reprocessTranslationsOnly() {
        const allCells = Array.from(document.querySelectorAll(`.ant-table-tbody > tr > td:nth-child(${COLUMN_INDEX})`));
        allCells.forEach(cell => {
            const trans = cell.querySelector('.translation');
            if (trans) trans.remove();
            cell.dataset.translated = '';
            translateIfNeeded(cell);
        });
    }

    function removeTranslationsOnly() {
        const allCells = Array.from(document.querySelectorAll(`.ant-table-tbody > tr > td:nth-child(${COLUMN_INDEX})`));
        allCells.forEach(cell => {
            const trans = cell.querySelector('.translation');
            if (trans) trans.remove();
            cell.dataset.translated = 'false';
            adjustFontSizeForCell(cell);
        });
    }

    function adjustFontSizesOnly() {
        const allCells = Array.from(document.querySelectorAll(`.ant-table-tbody > tr > td:nth-child(${COLUMN_INDEX})`));
        allCells.forEach(cell => {
            adjustFontSizeForCell(cell);
        });
    }

    // ====== ä¿®å¤çš„å…¨å±€æ ·å¼ (ä¿æŒåŸç‰ˆ) ======
    function addGlobalStyle() {
        const style = document.createElement('style');
        style.textContent = `
            .ant-table-tbody > tr > td:nth-child(${COLUMN_INDEX}) {
                position: relative !important;
                vertical-align: top !important;
                padding: 0 !important;
                height: auto !important;
            }
            .fixed-height-cell {
                position: relative;
                width: 100%;
                max-height: ${MAX_CELL_HEIGHT}px;
                overflow-y: auto;
                padding: 4px 6px;
                box-sizing: border-box;
                line-height: 1.1;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-size: ${MIN_FONT_SIZE}px;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
            }
            .fixed-height-cell.single-line {
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                height: ${SINGLE_LINE_HEIGHT}px;
                line-height: ${SINGLE_LINE_HEIGHT}px;
            }
            .fixed-height-cell.no-scroll { overflow: hidden; }
            .fixed-height-cell .original { display: inline; font-weight: normal; }
            .fixed-height-cell .translation { display: inline; font-weight: bold !important; margin-left: 8px; }
            .fixed-height-cell.long-text {
                cursor: pointer;
                background: linear-gradient(135deg, rgba(24, 144, 255, 0.05) 0%, rgba(24, 144, 255, 0.1) 100%);
            }
            .fixed-height-cell.${EXPANDED_CLASS} {
                max-height: none !important;
                overflow: visible !important;
                background: rgba(24, 144, 255, 0.05);
                border: 1px solid rgba(24, 144, 255, 0.3);
                border-radius: 6px;
                padding: 8px;
                z-index: 50;
            }
            
            /* æŒ‰é’®æ ·å¼ */
            .${COPY_BTN_CLASS}, .${ROLE_COPY_BTN_CLASS}, .${ROLE_ID_ONLY_COPY_BTN_CLASS} {
                position: absolute;
                background: rgba(255, 255, 255, 0.2);
                border: 1px solid rgba(0, 0, 0, 0.1);
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: all 0.2s ease;
                z-index: 10;
                color: #666;
            }
            .${COPY_BTN_CLASS} { top: 4px; right: 4px; width: 32px; height: 35px; font-size: 14px; }
            .${ROLE_COPY_BTN_CLASS} { top: 4px; right: 4px; width: 28px; height: 30px; font-size: 12px; font-weight: bold; }
            .${ROLE_ID_ONLY_COPY_BTN_CLASS} { top: 4px; left: 4px; width: 30px; height: 30px; font-size: 12px; font-weight: bold; }

            td:hover .${COPY_BTN_CLASS}, td:hover .${ROLE_COPY_BTN_CLASS}, td:hover .${ROLE_ID_ONLY_COPY_BTN_CLASS} {
                background: rgba(255, 255, 255, 0.8);
                border-color: rgba(24, 144, 255, 0.3);
            }
            .${COPY_BTN_CLASS}:hover, .${ROLE_COPY_BTN_CLASS}:hover, .${ROLE_ID_ONLY_COPY_BTN_CLASS}:hover {
                transform: scale(1.1);
                color: #1890ff;
                background: #fff;
            }
            .copied { color: #52c41a !important; border-color: #52c41a !important; }
            .error { color: #ff4d4f !important; border-color: #ff4d4f !important; }
        `;
        document.head.appendChild(style);
    }

    // ====== Role ID åŠŸèƒ½ (ä¿ç•™) ======
    function findRoleIdColumns() {
        const headers = document.querySelectorAll('.ant-table-thead th');
        roleIdColumnIndexes = [];
        headers.forEach((header) => {
            const text = getCleanCellText(header);
            if (text && /role_?id/i.test(text)) {
                const columnIndex = Array.from(header.parentElement.children).indexOf(header) + 1;
                if (columnIndex !== COLUMN_INDEX && !roleIdColumnIndexes.includes(columnIndex)) {
                    roleIdColumnIndexes.push(columnIndex);
                }
            }
        });
    }

    function addRoleIdOnlyCopyButtons() {
        if (roleIdColumnIndexes.length === 0) findRoleIdColumns();
        roleIdColumnIndexes.forEach(columnIndex => {
            const roleCells = document.querySelectorAll(`.ant-table-tbody > tr > td:nth-child(${columnIndex})`);
            roleCells.forEach(cell => {
                if (cell.querySelector(`.${ROLE_ID_ONLY_COPY_BTN_CLASS}`)) return;
                const roleText = getCleanCellText(cell);
                if (roleText && roleText.trim()) {
                    addRoleIdOnlyCopyButton(cell, roleText.trim());
                }
            });
        });
    }

    function addRoleIdOnlyCopyButton(cell, roleText) {
        const copyBtn = document.createElement('div');
        copyBtn.className = ROLE_ID_ONLY_COPY_BTN_CLASS;
        copyBtn.title = 'ç‚¹å‡»å¤åˆ¶role_id';
        copyBtn.textContent = '-';
        
        copyBtn.onclick = (e) => {
            e.stopPropagation();
            copyToClipboard(roleText, copyBtn, '-');
        };
        cell.style.position = 'relative';
        cell.appendChild(copyBtn);
    }

    function addCopyButtonsToRoleIdColumns() {
        roleIdColumnIndexes.forEach(columnIndex => {
            const roleCells = document.querySelectorAll(`.ant-table-tbody > tr > td:nth-child(${columnIndex})`);
            roleCells.forEach(cell => {
                if (cell.querySelector(`.${ROLE_COPY_BTN_CLASS}`)) return;
                if (getCleanCellText(cell)) {
                    addRoleCopyButton(cell);
                }
            });
        });
    }

    function addRoleCopyButton(cell) {
        const copyBtn = document.createElement('div');
        copyBtn.className = ROLE_COPY_BTN_CLASS;
        copyBtn.title = 'ç‚¹å‡»å¤åˆ¶ç¬¬8åˆ—åŸæ–‡å’Œrole_id';
        copyBtn.textContent = '+';
        
        copyBtn.onclick = (e) => {
            e.stopPropagation();
            const row = cell.closest('tr');
            const col8Cell = row.querySelector(`td:nth-child(${COLUMN_INDEX})`);
            const col8Text = col8Cell ? (col8Cell.dataset.originalText || getCleanCellText(col8Cell)) : '';
            let roleText = getCleanCellText(cell).replace('+', '').trim();
            
            if (col8Text || roleText) {
                copyToClipboard(col8Text + '\n' + roleText, copyBtn, '+');
            }
        };
        cell.style.position = 'relative';
        cell.appendChild(copyBtn);
    }

    // ====== æ™ºèƒ½æŒ‰é’®é«˜åº¦é€‚é… (ä¿ç•™) ======
    function initButtonHeightAdapter() {
        setInterval(processAllTargetButtons, BUTTON_ADAPTER_CONFIG.checkInterval);
    }

    function processAllTargetButtons() {
        if (!BUTTON_ADAPTER_CONFIG.isEnabled) return;
        const allButtons = document.querySelectorAll(BUTTON_ADAPTER_CONFIG.targetButtons);
        allButtons.forEach(button => {
            if (isTargetButton(button) && !processedButtons.has(button)) {
                adaptButtonHeight(button);
            }
        });
    }

    function isTargetButton(button) {
        const text = button.textContent.trim();
        return BUTTON_ADAPTER_CONFIG.targetButtonTexts.some(targetText => text.includes(targetText));
    }

    function adaptButtonHeight(button) {
        const row = button.closest('tr');
        if (!row) return;
        
        // ä»¥ç¬¬8åˆ—é«˜åº¦ä¸ºåŸºå‡†
        const targetCell = row.querySelector(`td:nth-child(${COLUMN_INDEX}) .fixed-height-cell`);
        if (!targetCell) return;
        
        let height = targetCell.scrollHeight + BUTTON_ADAPTER_CONFIG.buttonHeightOffset;
        height = Math.min(Math.max(height, BUTTON_ADAPTER_CONFIG.minButtonHeight), BUTTON_ADAPTER_CONFIG.maxButtonHeight);
        
        button.style.height = height + 'px';
        button.style.lineHeight = height + 'px';
        processedButtons.add(button);
    }

    function scheduleButtonAdaptationForRow(row) {
        if (!row || !BUTTON_ADAPTER_CONFIG.isEnabled) return;
        setTimeout(() => {
            const buttons = row.querySelectorAll(BUTTON_ADAPTER_CONFIG.targetButtons);
            buttons.forEach(button => {
                if (isTargetButton(button)) adaptButtonHeight(button);
            });
        }, BUTTON_ADAPTER_CONFIG.translationWaitTime);
    }

    // ====== æ ¸å¿ƒè¾…åŠ©å‡½æ•° (ä¿®å¤å¤åˆ¶å’Œå»é‡) ======
    function getCleanCellText(cell) {
        if (!cell) return '';
        const clone = cell.cloneNode(true);
        // ç§»é™¤æŒ‰é’®å†è·å–æ–‡æœ¬
        const buttons = clone.querySelectorAll(`.${COPY_BTN_CLASS}, .${ROLE_COPY_BTN_CLASS}, .${ROLE_ID_ONLY_COPY_BTN_CLASS}, button`);
        buttons.forEach(btn => btn.remove());
        return clone.textContent.trim();
    }

    async function copyToClipboard(text, btn, originalIcon) {
        try {
            await navigator.clipboard.writeText(text);
            btn.textContent = 'âœ“';
            btn.classList.add('copied');
            setTimeout(() => {
                btn.textContent = originalIcon;
                btn.classList.remove('copied');
            }, 1000);
        } catch (err) {
            btn.textContent = 'âœ—';
            btn.classList.add('error');
            setTimeout(() => {
                btn.textContent = originalIcon;
                btn.classList.remove('error');
            }, 1000);
        }
    }

    function wrapCellContent(cell) {
        const text = getCleanCellText(cell);
        if (!text) return;

        // ä¿®å¤ï¼šé˜²æ­¢é‡å¤åŒ…è£…ï¼Œå…ˆæ¸…ç©º
        cell.innerHTML = '';
        cell.dataset.originalText = text;

        const container = document.createElement('div');
        container.className = 'fixed-height-cell';

        const originalSpan = document.createElement('span');
        originalSpan.className = 'original';
        originalSpan.textContent = text;

        container.appendChild(originalSpan);
        cell.appendChild(container);

        addCopyButtonToCell(cell);

        // é•¿æ–‡æœ¬äº¤äº’
        if (text.length > SINGLE_LINE_CHAR_LIMIT) {
            container.classList.add('long-text');
            container.addEventListener('click', (e) => {
                e.stopPropagation();
                if (container.classList.contains(EXPANDED_CLASS)) {
                    container.classList.remove(EXPANDED_CLASS);
                    adjustFontSizeForCell(cell);
                } else {
                    container.classList.add(EXPANDED_CLASS);
                    container.style.fontSize = '16px';
                }
            });
        }
    }

    function addCopyButtonToCell(cell) {
        const copyBtn = document.createElement('div');
        copyBtn.className = COPY_BTN_CLASS;
        copyBtn.title = 'ç‚¹å‡»å¤åˆ¶åŸæ–‡';
        copyBtn.textContent = '+';
        
        copyBtn.onclick = (e) => {
            e.stopPropagation();
            const text = cell.dataset.originalText || getCleanCellText(cell);
            copyToClipboard(text, copyBtn, '+');
        };
        cell.appendChild(copyBtn);
    }

    // ====== ä¿®å¤çš„å­—ä½“è°ƒæ•´ (æ€§èƒ½ä¼˜åŒ–æ ¸å¿ƒ) ======
    function adjustFontSizeForCell(cell) {
        const container = cell.querySelector('.fixed-height-cell');
        if (!container || container.classList.contains(EXPANDED_CLASS)) return;

        let displayText = '';
        const originalSpan = container.querySelector('.original');
        const translationSpan = container.querySelector('.translation');
        if (originalSpan) displayText += originalSpan.textContent;
        if (translationSpan) displayText += ' ' + translationSpan.textContent;
        if (!displayText) displayText = cell.dataset.originalText || '';

        // ä½¿ç”¨å…¨å±€å®¹å™¨æµ‹é‡
        if (!globalMeasureContainer) createMeasureContainer();
        
        globalMeasureContainer.style.width = container.clientWidth + 'px';
        // ç®€å•æ¨¡æ‹Ÿå†…å®¹
        globalMeasureContainer.textContent = displayText;

        let fontSize = MAX_FONT_SIZE;
        
        // å¦‚æœæ˜¯å•è¡Œæ¨¡å¼
        const charCount = displayText.length;
        if (charCount <= SINGLE_LINE_CHAR_LIMIT) {
            container.classList.add('single-line');
            // å°è¯•æœ€å¤§å­—ä½“
             globalMeasureContainer.style.fontSize = fontSize + 'px';
             // ç®€å•é™çº§
             while (fontSize > MIN_FONT_SIZE && globalMeasureContainer.scrollHeight > SINGLE_LINE_HEIGHT * 1.2) {
                 fontSize -= 2;
                 globalMeasureContainer.style.fontSize = fontSize + 'px';
             }
        } else {
            container.classList.remove('single-line');
            // å¿«é€Ÿé€¼è¿‘
            globalMeasureContainer.style.fontSize = fontSize + 'px';
            while (fontSize > MIN_FONT_SIZE && globalMeasureContainer.scrollHeight > MAX_CELL_HEIGHT) {
                fontSize -= 1;
                globalMeasureContainer.style.fontSize = fontSize + 'px';
            }
        }

        container.style.fontSize = fontSize + 'px';
        
        // æ»šåŠ¨æ¡çŠ¶æ€
        if (container.scrollHeight > MAX_CELL_HEIGHT + 5) {
             container.classList.remove('no-scroll');
        } else {
             container.classList.add('no-scroll');
        }
    }

    // ====== ç¿»è¯‘é€»è¾‘ (ä¿æŒ) ======
    async function translateIfNeeded(cell) {
        const originalText = cell.dataset.originalText;
        if (!originalText || originalText.length < 2 || cell.dataset.translated === 'true') return;

        if (translationCache.has(originalText)) {
            applyTranslation(cell, translationCache.get(originalText));
            return;
        }

        try {
            const translatedText = await translateText(originalText);
            if (translatedText && translatedText !== originalText) {
                translationCache.set(originalText, translatedText);
                applyTranslation(cell, translatedText);
            }
        } catch (e) {}
    }

    function applyTranslation(cell, translatedText) {
        const container = cell.querySelector('.fixed-height-cell');
        if (!container || container.querySelector('.translation')) return;

        const span = document.createElement('span');
        span.className = 'translation';
        span.textContent = translatedText;
        container.appendChild(span);
        
        cell.dataset.translated = 'true';
        adjustFontSizeForCell(cell);
    }

    async function translateText(text) {
        return new Promise((resolve) => {
            const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=zh-CN&dt=t&q=${encodeURIComponent(text)}`;
            GM_xmlhttpRequest({
                method: 'GET',
                url: url,
                timeout: 8000,
                onload: res => {
                    try {
                        const data = JSON.parse(res.responseText);
                        let result = '';
                        if (data[0]) data[0].forEach(item => { if(item[0]) result += item[0]; });
                        resolve(result || text);
                    } catch (e) { resolve(text); }
                },
                onerror: () => resolve(text)
            });
        });
    }

    function setupTableSortDetection() {
        // é…åˆ startStableMonitoring ä½¿ç”¨ï¼Œè¿™é‡Œç•™ç©ºæˆ–ç®€å•é€»è¾‘
    }

    function bindShortcut() {
        document.addEventListener('keydown', (e) => {
            if (e.altKey && e.key.toLowerCase() === 'z') {
                isTranslationEnabled = !isTranslationEnabled;
                saveSettings();
                controlPanel.querySelector('#translation-toggle').checked = isTranslationEnabled;
                if (isTranslationEnabled) reprocessTranslationsOnly();
                else removeTranslationsOnly();
                showNotification(`ç¿»è¯‘å·²${isTranslationEnabled?'å¼€å¯':'å…³é—­'}`);
            }
        });
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();
